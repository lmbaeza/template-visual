{
    "componentChunkName": "component---src-templates-module-template-tsx",
    "path": "/silver/custom-cpp-stl",
    "result": {"data":{"xdm":{"body":"/*@jsxRuntime automatic @jsxImportSource react*/\nconst {Fragment: _Fragment, jsx: _jsx, jsxs: _jsxs} = arguments[0];\nfunction _missingComponent(name) {\n  return function () {\n    throw new Error(\"Component `\" + name + \"` was not imported, exported, or given\");\n  };\n}\nconst id = \"custom-cpp-stl\", title = \"(Optional) C++ Sets with Custom Comparators\", author = \"Benjamin Qi, Siyong Huang\", prerequisites = [\"sorting-custom\", \"intro-sorted-sets\"], description = \"Incorporating custom comparators into standard library containers.\", frequency = 1;\nfunction MDXContent(_props) {\n  const _components = Object.assign({\n    p: \"p\",\n    code: \"code\",\n    a: \"a\",\n    h2: \"h2\",\n    blockquote: \"blockquote\",\n    pre: \"pre\",\n    h3: \"h3\",\n    strong: \"strong\",\n    Resources: _missingComponent(\"Resources\"),\n    Resource: _missingComponent(\"Resource\"),\n    HeaderLink: _missingComponent(\"HeaderLink\"),\n    Info: _missingComponent(\"Info\")\n  }, _props.components), {Resources, Resource, HeaderLink, Info, wrapper: MDXLayout} = _components;\n  const _content = _jsxs(_Fragment, {\n    children: [_jsxs(Resources, {\n      children: [_jsx(Resource, {\n        source: \"fushar\",\n        title: \"Comparison Functions in C++\",\n        starred: true,\n        url: \"https://web.archive.org/web/20200412101638/http://fusharblog.com/3-ways-to-define-comparison-functions-in-cpp/\",\n        children: _jsx(_components.p, {\n          children: \"Covers all of this material.\"\n        })\n      }), _jsx(Resource, {\n        source: \"CPP\",\n        url: \"https://en.cppreference.com/w/cpp/container/set\",\n        title: \"Set\",\n        children: _jsx(_components.p, {\n          children: \"reference\"\n        })\n      })]\n    }), \"\\n\", _jsx(\"br\", {}), \"\\n\", _jsxs(_components.p, {\n      children: [\"What if we want to use a C++ \", _jsx(_components.code, {\n        children: \"set\"\n      }), \" with the \", _jsx(_components.code, {\n        children: \"Edge\"\n      }), \" struct that was defined in\\n\", _jsx(_components.a, {\n        href: \"/silver/sorting-custom\",\n        children: \"Sorting with Custom Comparators\"\n      }), \"?\"]\n    }), \"\\n\", _jsxs(_components.h2, {\n      id: \"operator-overloading\",\n      children: [_jsx(_components.a, {\n        href: \"#operator-overloading\",\n        \"aria-hidden\": \"true\",\n        tabIndex: \"-1\",\n        className: \"anchor before\",\n        children: _jsx(HeaderLink, {})\n      }), \"Operator Overloading\"]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"Works as expected, although you should make sure to include the second \", _jsx(_components.code, {\n        children: \"const\"\n      }), \"\\nor you'll get a compilation error. From the link above:\"]\n    }), \"\\n\", _jsxs(_components.blockquote, {\n      children: [\"\\n\", _jsx(_components.p, {\n        children: \"[The second const] means you cannot modify member variables of the current\\nobject.\"\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        className: \"language-cpp\",\n        children: \"#include <bits/stdc++.h>\\nusing namespace std;\\n\\nstruct Edge {\\n\\tint a,b,w;\\n\\tbool operator<(const Edge& y) const { return w < y.w; }\\n};\\n\\nint main() {\\n\\tint M = 4;\\n\\tset<Edge> v;\\n\\tfor (int i = 0; i < M; ++i) {\\n\\t\\tint a,b,w; cin >> a >> b >> w;\\n\\t\\tv.insert({a,b,w});\\n\\t}\\n\\tfor (Edge e: v) cout << e.a << \\\" \\\" << e.b << \\\" \\\" << e.w << \\\"\\\\n\\\";\\n}\\n\"\n      })\n    }), \"\\n\", _jsxs(_components.h2, {\n      id: \"comparator\",\n      children: [_jsx(_components.a, {\n        href: \"#comparator\",\n        \"aria-hidden\": \"true\",\n        tabIndex: \"-1\",\n        className: \"anchor before\",\n        children: _jsx(HeaderLink, {})\n      }), \"Comparator\"]\n    }), \"\\n\", _jsx(Resources, {\n      children: _jsx(Resource, {\n        source: \"SO\",\n        title: \"Using custom std::set comparator\",\n        url: \"https://stackoverflow.com/questions/2620862/using-custom-stdset-comparator\"\n      })\n    }), \"\\n\", _jsxs(_components.h3, {\n      id: \"with-a-function\",\n      children: [_jsx(_components.a, {\n        href: \"#with-a-function\",\n        \"aria-hidden\": \"true\",\n        tabIndex: \"-1\",\n        className: \"anchor before\",\n        children: _jsx(HeaderLink, {})\n      }), \"With a Function\"]\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        className: \"language-cpp\",\n        children: \"#include <bits/stdc++.h>\\nusing namespace std;\\n\\nstruct Edge {\\n\\tint a,b,w;\\n};\\n\\nbool cmp(const Edge& x, const Edge& y) { return x.w < y.w; }\\n\\nint main() {\\n\\tint M = 4;\\n\\tset<Edge,bool(*)(const Edge&,const Edge&)> v(cmp);\\n\\tfor (int i = 0; i < M; ++i) {\\n\\t\\tint a,b,w; cin >> a >> b >> w;\\n\\t\\tv.insert({a,b,w});\\n\\t}\\n\\tfor (Edge e: v) cout << e.a << \\\" \\\" << e.b << \\\" \\\" << e.w << \\\"\\\\n\\\";\\n}\\n\"\n      })\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"You can also use the following syntax to declare set \", _jsx(_components.code, {\n        children: \"v\"\n      }), \" using a function:\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsx(_components.code, {\n        children: \"set<Edge,decltype(&cmp)> v(cmp);\"\n      })\n    }), \"\\n\", _jsxs(_components.h3, {\n      id: \"with-lambda-expressions\",\n      children: [_jsx(_components.a, {\n        href: \"#with-lambda-expressions\",\n        \"aria-hidden\": \"true\",\n        tabIndex: \"-1\",\n        className: \"anchor before\",\n        children: _jsx(HeaderLink, {})\n      }), \"With Lambda Expressions\"]\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        className: \"language-cpp\",\n        children: \"auto cmp = [](const Edge& x, const Edge& y) { return x.w < y.w; };\\n\\nint main() {\\n\\tint M = 4;\\n\\tset<Edge,bool(*)(const Edge&,const Edge&)> v(cmp);\\n\\tfor (int i = 0; i < M; ++i) {\\n\\t\\tint a,b,w; cin >> a >> b >> w;\\n\\t\\tv.insert({a,b,w});\\n\\t}\\n\\tfor (Edge e: v) cout << e.a << \\\" \\\" << e.b << \\\" \\\" << e.w << \\\"\\\\n\\\";\\n}\\n\"\n      })\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"You can also use the following syntax to declare set \", _jsx(_components.code, {\n        children: \"v\"\n      }), \" using a lambda\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsx(_components.code, {\n        children: \"set<Edge,decltype(cmp)> v(cmp);\"\n      })\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"even though \", _jsx(_components.code, {\n        children: \"decltype(cmp)\"\n      }), \" is \", _jsx(_components.strong, {\n        children: \"not\"\n      }), \" actually equivalent to\\n\", _jsx(_components.code, {\n        children: \"bool(*)(const Edge&,const Edge&)\"\n      }), \". See \", _jsx(_components.a, {\n        href: \"/general/lambda\",\n        children: \"Lambda Expressions\"\n      }), \"\\nfor details.\"]\n    }), \"\\n\", _jsxs(_components.h2, {\n      id: \"functors\",\n      children: [_jsx(_components.a, {\n        href: \"#functors\",\n        \"aria-hidden\": \"true\",\n        tabIndex: \"-1\",\n        className: \"anchor before\",\n        children: _jsx(HeaderLink, {})\n      }), \"Functors\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Probably less confusing than the method above.\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        className: \"language-cpp\",\n        children: \"#include <bits/stdc++.h>\\nusing namespace std;\\n\\nstruct Edge {\\n\\tint a,b,w;\\n};\\n\\nstruct cmp {\\n\\tbool operator()(const Edge& x, const Edge& y) const { return x.w < y.w; }\\n};\\n\\nint main() {\\n\\tint M = 4;\\n\\tset<Edge,cmp> v;\\n\\tfor (int i = 0; i < M; ++i) {\\n\\t\\tint a,b,w; cin >> a >> b >> w;\\n\\t\\tv.insert({a,b,w});\\n\\t}\\n\\tfor (Edge e: v) cout << e.a << \\\" \\\" << e.b << \\\" \\\" << e.w << \\\"\\\\n\\\";\\n}\\n\"\n      })\n    }), \"\\n\", _jsx(Info, {\n      title: \"Pro Tip\",\n      children: _jsx(_components.p, {\n        children: \"One functor can be used for multiple objects.\"\n      })\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"We can also use \", _jsx(_components.code, {\n        children: \"cmp\"\n      }), \" like a normal function by adding \", _jsx(_components.code, {\n        children: \"()\"\n      }), \" after it.\"]\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        className: \"language-cpp\",\n        children: \"int main() {\\n\\tint M = 4;\\n\\tvector<Edge> v;\\n\\tfor (int i = 0; i < M; ++i) {\\n\\t\\tint a,b,w; cin >> a >> b >> w;\\n\\t\\tv.push_back({a,b,w});\\n\\t}\\n\\tsort(begin(v),end(v),cmp());\\n\\tfor (Edge e: v) cout << e.a << \\\" \\\" << e.b << \\\" \\\" << e.w << \\\"\\\\n\\\";\\n}\\n\"\n      })\n    }), \"\\n\", _jsxs(_components.h3, {\n      id: \"built-in-functors\",\n      children: [_jsx(_components.a, {\n        href: \"#built-in-functors\",\n        \"aria-hidden\": \"true\",\n        tabIndex: \"-1\",\n        className: \"anchor before\",\n        children: _jsx(HeaderLink, {})\n      }), \"Built-In Functors\"]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"Overloading the less than operator (\", _jsx(_components.code, {\n        children: \"<\"\n      }), \") automatically generates the functor\\n\", _jsx(_components.a, {\n        href: \"https://en.cppreference.com/w/cpp/utility/functional/less\",\n        target: \"_blank\",\n        rel: \"nofollow noopener noreferrer\",\n        children: _jsx(_components.code, {\n          children: \"less<Edge>\"\n        })\n      }), \".\\nSimilarly, overloading (\", _jsx(_components.code, {\n        children: \">\"\n      }), \") automatically generates the functor\\n\", _jsx(_components.a, {\n        href: \"https://en.cppreference.com/w/cpp/utility/functional/greater\",\n        target: \"_blank\",\n        rel: \"nofollow noopener noreferrer\",\n        children: _jsx(_components.code, {\n          children: \"greater<Edge>\"\n        })\n      }), \".\\nWe can use this to store a set in reverse order.\"]\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        className: \"language-cpp\",\n        children: \"#include <bits/stdc++.h>\\nusing namespace std;\\n\\nstruct Edge {\\n\\tint a,b,w;\\n\\tbool operator>(const Edge& y) const { return w > y.w; }\\n};\\n\\nint main() {\\n\\tint M = 4;\\n\\tset<Edge,greater<Edge>> v;\\n\\tfor (int i = 0; i < M; ++i) {\\n\\t\\tint a,b,w; cin >> a >> b >> w;\\n\\t\\tv.insert({a,b,w});\\n\\t}\\n\\tfor (Edge e: v) cout << e.a << \\\" \\\" << e.b << \\\" \\\" << e.w << \\\"\\\\n\\\";\\n}\\n\\n/* Output:\\n2 3 10\\n1 2 9\\n1 3 7\\n2 4 3\\n*/\\n\"\n      })\n    }), \"\\n\", _jsxs(_components.h2, {\n      id: \"other-containers\",\n      children: [_jsx(_components.a, {\n        href: \"#other-containers\",\n        \"aria-hidden\": \"true\",\n        tabIndex: \"-1\",\n        className: \"anchor before\",\n        children: _jsx(HeaderLink, {})\n      }), \"Other Containers\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"The following are all valid:\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        className: \"language-cpp\",\n        children: \"set<int,greater<int>> a;\\nmap<int,string,greater<int>> b;\\npriority_queue<int,vector<int>,greater<int>> c;\\n\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Using a custom comparator for priority queues is especially common. Recall that\\na C++ priority queue will pop its largest element by default, while the above\\ncode will cause one to pop its smallest element instead.\"\n    }), \"\\n\", _jsxs(_components.h2, {\n      id: \"problems\",\n      children: [_jsx(_components.a, {\n        href: \"#problems\",\n        \"aria-hidden\": \"true\",\n        tabIndex: \"-1\",\n        className: \"anchor before\",\n        children: _jsx(HeaderLink, {})\n      }), \"Problems\"]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"Check the \", _jsx(_components.a, {\n        href: \"/plat/sweep-line#line-segments\",\n        children: \"Sweep Line\"\n      }), \" module for a task that\\nuses a set with a custom comparator.\"]\n    })]\n  });\n  return MDXLayout ? _jsx(MDXLayout, Object.assign({}, _props, {\n    children: _content\n  })) : _content;\n}\nreturn {\n  id,\n  title,\n  author,\n  prerequisites,\n  description,\n  frequency,\n  default: MDXContent\n};\n","frontmatter":{"title":"(Optional) C++ Sets with Custom Comparators","author":"Benjamin Qi, Siyong Huang","contributors":null,"id":"custom-cpp-stl","prerequisites":["sorting-custom","intro-sorted-sets"],"description":"Incorporating custom comparators into standard library containers.","frequency":1},"parent":{"name":"Custom_Cpp_STL","relativePath":"3_Silver/Custom_Cpp_STL.mdx"},"fields":{"division":"silver"},"toc":{"cpp":[{"depth":2,"value":"Operator Overloading","slug":"operator-overloading"},{"depth":2,"value":"Comparator","slug":"comparator"},{"depth":3,"value":"With a Function","slug":"with-a-function"},{"depth":3,"value":"With Lambda Expressions","slug":"with-lambda-expressions"},{"depth":2,"value":"Functors","slug":"functors"},{"depth":3,"value":"Built-In Functors","slug":"built-in-functors"},{"depth":2,"value":"Other Containers","slug":"other-containers"},{"depth":2,"value":"Problems","slug":"problems"}],"java":[{"depth":2,"value":"Operator Overloading","slug":"operator-overloading"},{"depth":2,"value":"Comparator","slug":"comparator"},{"depth":3,"value":"With a Function","slug":"with-a-function"},{"depth":3,"value":"With Lambda Expressions","slug":"with-lambda-expressions"},{"depth":2,"value":"Functors","slug":"functors"},{"depth":3,"value":"Built-In Functors","slug":"built-in-functors"},{"depth":2,"value":"Other Containers","slug":"other-containers"},{"depth":2,"value":"Problems","slug":"problems"}],"py":[{"depth":2,"value":"Operator Overloading","slug":"operator-overloading"},{"depth":2,"value":"Comparator","slug":"comparator"},{"depth":3,"value":"With a Function","slug":"with-a-function"},{"depth":3,"value":"With Lambda Expressions","slug":"with-lambda-expressions"},{"depth":2,"value":"Functors","slug":"functors"},{"depth":3,"value":"Built-In Functors","slug":"built-in-functors"},{"depth":2,"value":"Other Containers","slug":"other-containers"},{"depth":2,"value":"Problems","slug":"problems"}]}},"moduleProblemLists":{"problemLists":[]}},"pageContext":{"id":"custom-cpp-stl"}},
    "staticQueryHashes": ["3245546052","3813215756","745520438"]}