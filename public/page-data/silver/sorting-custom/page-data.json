{
    "componentChunkName": "component---src-templates-module-template-tsx",
    "path": "/silver/sorting-custom",
    "result": {"data":{"xdm":{"body":"/*@jsxRuntime automatic @jsxImportSource react*/\n/*Tested*/\nconst {Fragment: _Fragment, jsx: _jsx, jsxs: _jsxs} = arguments[0];\nfunction _missingComponent(name) {\n  return function () {\n    throw new Error(\"Component `\" + name + \"` was not imported, exported, or given\");\n  };\n}\nconst id = \"sorting-custom\", title = \"Custom Comparators and Coordinate Compression\", frequency = 3, author = \"Darren Yao, Siyong Huang, Michael Cao, Benjamin Qi, Nathan Chen\", prerequisites = [\"intro-sorting\", \"intro-graphs\"], description = \"Using a custom comparator to sort custom objects or values in a non-default order; Coordinate compressing values from a large range to a smaller one.\";\nfunction MDXContent(_props) {\n  const _components = Object.assign({\n    p: \"p\",\n    h2: \"h2\",\n    a: \"a\",\n    pre: \"pre\",\n    code: \"code\",\n    ul: \"ul\",\n    li: \"li\",\n    strong: \"strong\",\n    h3: \"h3\",\n    em: \"em\",\n    Resources: _missingComponent(\"Resources\"),\n    Resource: _missingComponent(\"Resource\"),\n    HeaderLink: _missingComponent(\"HeaderLink\"),\n    FocusProblem: _missingComponent(\"FocusProblem\"),\n    LanguageSection: _missingComponent(\"LanguageSection\"),\n    CPPSection: _missingComponent(\"CPPSection\"),\n    JavaSection: _missingComponent(\"JavaSection\"),\n    PySection: _missingComponent(\"PySection\"),\n    MATHSPAN: _missingComponent(\"MATHSPAN\"),\n    Warning: _missingComponent(\"Warning\"),\n    Spoiler: _missingComponent(\"Spoiler\"),\n    Info: _missingComponent(\"Info\"),\n    Problems: _missingComponent(\"Problems\")\n  }, _props.components), {Resources, Resource, HeaderLink, FocusProblem, LanguageSection, CPPSection, JavaSection, PySection, MATHSPAN, Warning, Spoiler, Info, Problems, wrapper: MDXLayout} = _components;\n  const _content = _jsxs(_Fragment, {\n    children: [_jsxs(Resources, {\n      children: [_jsx(Resource, {\n        source: \"IUSACO\",\n        title: \"8 - Sorting & Comparators\",\n        children: _jsx(_components.p, {\n          children: \"partially based off this\"\n        })\n      }), _jsx(Resource, {\n        source: \"CPH\",\n        title: \"3.2 - User-Defined Structs, Comparison Functions\",\n        children: _jsx(_components.p, {\n          children: \"short overview of what this module will cover\"\n        })\n      })]\n    }), \"\\n\", _jsx(\"br\", {}), \"\\n\", _jsxs(_components.h2, {\n      id: \"example---wormhole-sort\",\n      children: [_jsx(_components.a, {\n        href: \"#example---wormhole-sort\",\n        \"aria-hidden\": \"true\",\n        tabIndex: \"-1\",\n        className: \"anchor before\",\n        children: _jsx(HeaderLink, {})\n      }), \"Example - Wormhole Sort\"]\n    }), \"\\n\", _jsx(FocusProblem, {\n      problem: \"sample\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"We won't discuss the full solution here, as some of the concepts necessary for\\nsolving this problem will be introduced later in Silver. However, many solutions\\nto this problem start by sorting the edges in nondecreasing order of weight. For\\nexample, the sample contains the following edges:\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        children: \"1 2 9\\n1 3 7\\n2 3 10\\n2 4 3\\n\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"After sorting, it should look like\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        children: \"2 4 3\\n1 3 7\\n1 2 9\\n2 3 10\\n\"\n      })\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"With C++, the easiest method is to use a \", _jsx(_components.code, {\n        children: \"vector\"\n      }), \" of nested \", _jsx(_components.code, {\n        children: \"pair\"\n      }), \"s:\"]\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        className: \"language-cpp\",\n        children: \"#include <bits/stdc++.h>\\nusing namespace std;\\n\\n#define f first\\n#define s second\\n\\nint main() {\\n\\tint M = 4;\\n\\tvector<pair<int,pair<int,int>>> v;\\n\\tfor (int i = 0; i < M; ++i) {\\n\\t\\tint a,b,w; cin >> a >> b >> w;\\n\\t\\tv.push_back({w,{a,b}});\\n\\t}\\n\\tsort(begin(v),end(v));\\n\\tfor (auto e: v) cout << e.s.f << \\\" \\\" << e.s.s << \\\" \\\" << e.f << \\\"\\\\n\\\";\\n}\\n\"\n      })\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"or a \", _jsx(_components.code, {\n        children: \"vector\"\n      }), \" of \", _jsx(_components.code, {\n        children: \"array<int,3>\"\n      }), \"s or \", _jsx(_components.code, {\n        children: \"vector<int>\"\n      }), \"s:\"]\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        className: \"language-cpp\",\n        children: \"int main() {\\n\\tint M = 4;\\n\\tvector<array<int,3>> v; // or vector<vector<int>>\\n\\tfor (int i = 0; i < M; ++i) {\\n\\t\\tint a,b,w; cin >> a >> b >> w;\\n\\t\\tv.push_back({w,a,b});\\n\\t}\\n\\tsort(begin(v),end(v));\\n\\tfor (auto e: v) cout << e[1] << \\\" \\\" << e[2] << \\\" \\\" << e[0] << \\\"\\\\n\\\";\\n}\\n\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"In Python, we can use a list of lists.\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"But in Java, we can't sort an \", _jsx(_components.code, {\n        children: \"ArrayList\"\n      }), \" of \", _jsx(_components.code, {\n        children: \"ArrayList\"\n      }), \"s without writing some\\nadditional code. What should we do?\"]\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsx(_components.li, {\n        children: \"If we only stored the edge weights and sorted them, we would have a sorted\\nlist of edge weights, but it would be impossible to tell which weights\\ncorresponded to which edges.\"\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [\"However, if we create a \", _jsx(_components.strong, {\n          children: \"class\"\n        }), \" representing the edges and define a \", _jsx(_components.strong, {\n          children: \"custom\\ncomparator\"\n        }), \" to sort them by weight, we can sort the edges in ascending order\\nwhile also keeping track of their endpoints.\"]\n      }), \"\\n\"]\n    }), \"\\n\", _jsxs(_components.h2, {\n      id: \"classes\",\n      children: [_jsx(_components.a, {\n        href: \"#classes\",\n        \"aria-hidden\": \"true\",\n        tabIndex: \"-1\",\n        className: \"anchor before\",\n        children: _jsx(HeaderLink, {})\n      }), \"Classes\"]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"First, we need to define a \", _jsx(_components.strong, {\n        children: \"class\"\n      }), \" that represents what we want to sort. In\\nour example we will define a class \", _jsx(_components.code, {\n        children: \"Edge\"\n      }), \" that contains the two endpoints of the\\nedge and the weight.\"]\n    }), \"\\n\", _jsxs(LanguageSection, {\n      children: [_jsxs(CPPSection, {\n        children: [_jsxs(_components.h3, {\n          id: \"c\",\n          children: [_jsx(_components.a, {\n            href: \"#c\",\n            \"aria-hidden\": \"true\",\n            tabIndex: \"-1\",\n            className: \"anchor before\",\n            children: _jsx(HeaderLink, {})\n          }), \"C++\"]\n        }), _jsxs(_components.p, {\n          children: [\"A C++ \", _jsx(_components.code, {\n            children: \"struct\"\n          }), \" is the same as a \", _jsx(_components.code, {\n            children: \"class\"\n          }), \" in C++, but all members are public by\\ndefault.\"]\n        }), _jsx(_components.pre, {\n          children: _jsx(_components.code, {\n            className: \"language-cpp\",\n            children: \"#include <bits/stdc++.h>\\nusing namespace std;\\n\\nstruct Edge {\\n\\tint a,b,w;\\n};\\n\\n/* alternatively,\\nclass Edge {\\n\\tpublic:\\n\\t\\tint a,b,w;\\n};\\n*/\\n\\nint main() {\\n\\tint M = 4;\\n\\tvector<Edge> v;\\n\\tfor (int i = 0; i < M; ++i) {\\n\\t\\tint a,b,w; cin >> a >> b >> w;\\n\\t\\tv.push_back({a,b,w});\\n\\t}\\n\\tfor (Edge e: v) cout << e.a << \\\" \\\" << e.b << \\\" \\\" << e.w << \\\"\\\\n\\\";\\n}\\n\"\n          })\n        })]\n      }), _jsx(JavaSection, {\n        children: _jsx(_components.pre, {\n          children: _jsx(_components.code, {\n            className: \"language-java\",\n            children: \"import java.util.*;\\n\\npublic class Sol {\\n\\tstatic class Edge {\\n\\t\\tint a,b,w;\\n\\t\\tpublic Edge(int _a, int _b, int _w) { a = _a; b = _b; w = _w; }\\n\\t}\\n\\tpublic static void main(String[] args) {\\n\\t\\tint M = 4;\\n\\t\\tScanner in = new Scanner(System.in);\\n\\t\\tArrayList<Edge> v = new ArrayList<Edge>();\\n\\t\\tfor (int i = 0; i < M; ++i) {\\n\\t\\t\\tint a = in.nextInt();\\n\\t\\t\\tint b = in.nextInt();\\n\\t\\t\\tint w = in.nextInt();\\n\\t\\t\\tv.add(new Edge(a,b,w));\\n\\t\\t}\\n\\t\\tfor (Edge e: v){\\n\\t\\t\\tSystem.out.print(e.a);\\n\\t\\t\\tSystem.out.print(' ');\\n\\t\\t\\tSystem.out.print(e.b);\\n\\t\\t\\tSystem.out.print(' ');\\n\\t\\t\\tSystem.out.println(e.w);\\n\\t\\t}\\n\\t}\\n}\\n\"\n          })\n        })\n      }), _jsx(PySection, {\n        children: _jsx(_components.pre, {\n          children: _jsx(_components.code, {\n            className: \"language-py\",\n            children: \"class Edge:\\n\\tdef __init__(self, a, b, w):\\n\\t\\tself.a = a\\n\\t\\tself.b = b\\n\\t\\tself.w = w\\n\\nv = []\\nM = 4\\nfor i in range(M):\\n\\ta,b,w = map(int,input().split())\\n\\tv.append(Edge(a,b,w))\\nfor e in v:\\n\\tprint(e.a,e.b,e.w)\\n\"\n          })\n        })\n      })]\n    }), \"\\n\", _jsxs(_components.h2, {\n      id: \"comparators\",\n      children: [_jsx(_components.a, {\n        href: \"#comparators\",\n        \"aria-hidden\": \"true\",\n        tabIndex: \"-1\",\n        className: \"anchor before\",\n        children: _jsx(HeaderLink, {})\n      }), \"Comparators\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Normally, sorting functions rely on moving objects with a lower value in front\\nof objects with a higher value if sorting in ascending order, and vice versa if\\nin descending order. This is done through comparing two objects at a time.\"\n    }), \"\\n\", _jsxs(LanguageSection, {\n      children: [_jsxs(CPPSection, {\n        children: [_jsx(_components.p, {\n          children: \"What a comparator does is compare two objects as follows, based on our\\ncomparison criteria:\"\n        }), _jsxs(_components.ul, {\n          children: [\"\\n\", _jsxs(_components.li, {\n            children: [\"If object \", _jsx(MATHSPAN, {\n              className: \"math math-inline\",\n              latex: \"x\",\n              children: \"<span class=\\\"katex\\\"><span class=\\\"katex-mathml\\\"><math xmlns=\\\"http://www.w3.org/1998/Math/MathML\\\"><semantics><mrow><mi>x</mi></mrow><annotation encoding=\\\"application/x-tex\\\">x</annotation></semantics></math></span><span class=\\\"katex-html\\\" aria-hidden=\\\"true\\\"><span class=\\\"base\\\"><span class=\\\"strut\\\" style=\\\"height:0.4306em;\\\"></span><span class=\\\"mord mathnormal\\\">x</span></span></span></span>\"\n            }), \" is less than object \", _jsx(MATHSPAN, {\n              className: \"math math-inline\",\n              latex: \"y\",\n              children: \"<span class=\\\"katex\\\"><span class=\\\"katex-mathml\\\"><math xmlns=\\\"http://www.w3.org/1998/Math/MathML\\\"><semantics><mrow><mi>y</mi></mrow><annotation encoding=\\\"application/x-tex\\\">y</annotation></semantics></math></span><span class=\\\"katex-html\\\" aria-hidden=\\\"true\\\"><span class=\\\"base\\\"><span class=\\\"strut\\\" style=\\\"height:0.625em;vertical-align:-0.1944em;\\\"></span><span class=\\\"mord mathnormal\\\" style=\\\"margin-right:0.03588em;\\\">y</span></span></span></span>\"\n            }), \", return \", _jsx(_components.code, {\n              children: \"true\"\n            })]\n          }), \"\\n\", _jsxs(_components.li, {\n            children: [\"If object \", _jsx(MATHSPAN, {\n              className: \"math math-inline\",\n              latex: \"x\",\n              children: \"<span class=\\\"katex\\\"><span class=\\\"katex-mathml\\\"><math xmlns=\\\"http://www.w3.org/1998/Math/MathML\\\"><semantics><mrow><mi>x</mi></mrow><annotation encoding=\\\"application/x-tex\\\">x</annotation></semantics></math></span><span class=\\\"katex-html\\\" aria-hidden=\\\"true\\\"><span class=\\\"base\\\"><span class=\\\"strut\\\" style=\\\"height:0.4306em;\\\"></span><span class=\\\"mord mathnormal\\\">x</span></span></span></span>\"\n            }), \" is greater than or equal to object \", _jsx(MATHSPAN, {\n              className: \"math math-inline\",\n              latex: \"y\",\n              children: \"<span class=\\\"katex\\\"><span class=\\\"katex-mathml\\\"><math xmlns=\\\"http://www.w3.org/1998/Math/MathML\\\"><semantics><mrow><mi>y</mi></mrow><annotation encoding=\\\"application/x-tex\\\">y</annotation></semantics></math></span><span class=\\\"katex-html\\\" aria-hidden=\\\"true\\\"><span class=\\\"base\\\"><span class=\\\"strut\\\" style=\\\"height:0.625em;vertical-align:-0.1944em;\\\"></span><span class=\\\"mord mathnormal\\\" style=\\\"margin-right:0.03588em;\\\">y</span></span></span></span>\"\n            }), \", return \", _jsx(_components.code, {\n              children: \"false\"\n            })]\n          }), \"\\n\"]\n        }), _jsxs(_components.p, {\n          children: [\"Essentially, the comparator determines whether object \", _jsx(MATHSPAN, {\n            className: \"math math-inline\",\n            latex: \"x\",\n            children: \"<span class=\\\"katex\\\"><span class=\\\"katex-mathml\\\"><math xmlns=\\\"http://www.w3.org/1998/Math/MathML\\\"><semantics><mrow><mi>x</mi></mrow><annotation encoding=\\\"application/x-tex\\\">x</annotation></semantics></math></span><span class=\\\"katex-html\\\" aria-hidden=\\\"true\\\"><span class=\\\"base\\\"><span class=\\\"strut\\\" style=\\\"height:0.4306em;\\\"></span><span class=\\\"mord mathnormal\\\">x</span></span></span></span>\"\n          }), \" belongs to the left of\\nobject \", _jsx(MATHSPAN, {\n            className: \"math math-inline\",\n            latex: \"y\",\n            children: \"<span class=\\\"katex\\\"><span class=\\\"katex-mathml\\\"><math xmlns=\\\"http://www.w3.org/1998/Math/MathML\\\"><semantics><mrow><mi>y</mi></mrow><annotation encoding=\\\"application/x-tex\\\">y</annotation></semantics></math></span><span class=\\\"katex-html\\\" aria-hidden=\\\"true\\\"><span class=\\\"base\\\"><span class=\\\"strut\\\" style=\\\"height:0.625em;vertical-align:-0.1944em;\\\"></span><span class=\\\"mord mathnormal\\\" style=\\\"margin-right:0.03588em;\\\">y</span></span></span></span>\"\n          }), \" in a sorted ordering.\"]\n        }), _jsx(Warning, {\n          children: _jsxs(_components.p, {\n            children: [\"A comparator \", _jsx(_components.strong, {\n              children: \"must\"\n            }), \" return false for two equal objects (not doing so results\\nin undefined behavior and potentially a verdict of wrong answer or runtime\\nerror).\"]\n          })\n        }), _jsx(_components.p, {\n          children: \"In addition to returning the correct answer, comparators should also satisfy the\\nfollowing conditions:\"\n        }), _jsxs(_components.ul, {\n          children: [\"\\n\", _jsxs(_components.li, {\n            children: [\"The function must be consistent with respect to reversing the order of the\\narguments: if \", _jsx(MATHSPAN, {\n              className: \"math math-inline\",\n              latex: \"x \\\\neq y\",\n              children: \"<span class=\\\"katex\\\"><span class=\\\"katex-mathml\\\"><math xmlns=\\\"http://www.w3.org/1998/Math/MathML\\\"><semantics><mrow><mi>x</mi><mo mathvariant=\\\"normal\\\">≠</mo><mi>y</mi></mrow><annotation encoding=\\\"application/x-tex\\\">x \\\\neq y</annotation></semantics></math></span><span class=\\\"katex-html\\\" aria-hidden=\\\"true\\\"><span class=\\\"base\\\"><span class=\\\"strut\\\" style=\\\"height:0.8889em;vertical-align:-0.1944em;\\\"></span><span class=\\\"mord mathnormal\\\">x</span><span class=\\\"mspace\\\" style=\\\"margin-right:0.2778em;\\\"></span><span class=\\\"mrel\\\"><span class=\\\"mrel\\\"><span class=\\\"mord vbox\\\"><span class=\\\"thinbox\\\"><span class=\\\"rlap\\\"><span class=\\\"strut\\\" style=\\\"height:0.8889em;vertical-align:-0.1944em;\\\"></span><span class=\\\"inner\\\"><span class=\\\"mord\\\"><span class=\\\"mrel\\\"></span></span></span><span class=\\\"fix\\\"></span></span></span></span></span><span class=\\\"mrel\\\">=</span></span><span class=\\\"mspace\\\" style=\\\"margin-right:0.2778em;\\\"></span></span><span class=\\\"base\\\"><span class=\\\"strut\\\" style=\\\"height:0.625em;vertical-align:-0.1944em;\\\"></span><span class=\\\"mord mathnormal\\\" style=\\\"margin-right:0.03588em;\\\">y</span></span></span></span>\"\n            }), \" and \", _jsx(_components.code, {\n              children: \"compare(x, y)\"\n            }), \" is \", _jsx(_components.code, {\n              children: \"true\"\n            }), \", then \", _jsx(_components.code, {\n              children: \"compare(y, x)\"\n            }), \"\\nshould be \", _jsx(_components.code, {\n              children: \"false\"\n            }), \" and vice versa.\"]\n          }), \"\\n\", _jsxs(_components.li, {\n            children: [\"The function must be transitive. If \", _jsx(_components.code, {\n              children: \"compare(x, y)\"\n            }), \" is true and\\n\", _jsx(_components.code, {\n              children: \"compare(y, z)\"\n            }), \" is true, then \", _jsx(_components.code, {\n              children: \"compare(x, z)\"\n            }), \" should also be true. If the\\nfirst two compare functions both return \", _jsx(_components.code, {\n              children: \"false\"\n            }), \", the third must also return\\n\", _jsx(_components.code, {\n              children: \"false\"\n            }), \".\"]\n          }), \"\\n\"]\n        }), _jsxs(_components.h3, {\n          id: \"method-1---overloading-the-less-than-operator\",\n          children: [_jsx(_components.a, {\n            href: \"#method-1---overloading-the-less-than-operator\",\n            \"aria-hidden\": \"true\",\n            tabIndex: \"-1\",\n            className: \"anchor before\",\n            children: _jsx(HeaderLink, {})\n          }), \"Method 1 - Overloading the Less Than Operator\"]\n        }), _jsx(_components.p, {\n          children: \"This is the easiest to implement. However, it only works for objects (not\\nprimitives) and it doesn't allow you to define multiple ways to compare the same\\ntype of class.\"\n        }), _jsxs(_components.p, {\n          children: [\"In the context of Wormhole Sort (note the use of\\n\", _jsx(_components.a, {\n            href: \"https://stackoverflow.com/questions/11805322/why-should-i-use-const-t-instead-of-const-t-or-t\",\n            target: \"_blank\",\n            rel: \"nofollow noopener noreferrer\",\n            children: \"const Edge&\"\n          }), \"):\"]\n        }), _jsx(_components.pre, {\n          children: _jsx(_components.code, {\n            className: \"language-cpp\",\n            children: \"#include <bits/stdc++.h>\\nusing namespace std;\\n\\nstruct Edge {\\n\\tint a,b,w;\\n\\tbool operator<(const Edge& y) { return w < y.w; }\\n};\\n\\nint main() {\\n\\tint M = 4;\\n\\tvector<Edge> v;\\n\\tfor (int i = 0; i < M; ++i) {\\n\\t\\tint a,b,w; cin >> a >> b >> w;\\n\\t\\tv.push_back({a,b,w});\\n\\t}\\n\\tsort(begin(v),end(v));\\n\\tfor (Edge e: v) cout << e.a << \\\" \\\" << e.b << \\\" \\\" << e.w << \\\"\\\\n\\\";\\n}\\n\"\n          })\n        }), _jsx(_components.p, {\n          children: \"We can also overload the operator outside of the class:\"\n        }), _jsx(_components.pre, {\n          children: _jsx(_components.code, {\n            className: \"language-cpp\",\n            children: \"struct Edge {\\n\\tint a,b,w;\\n};\\nbool operator<(const Edge& x, const Edge& y) { return x.w < y.w; }\\n\"\n          })\n        }), _jsxs(_components.p, {\n          children: [\"or within it using\\n\", _jsx(_components.a, {\n            href: \"https://www.geeksforgeeks.org/friend-class-function-cpp/\",\n            target: \"_blank\",\n            rel: \"nofollow noopener noreferrer\",\n            children: \"friend\"\n          }), \":\"]\n        }), _jsx(_components.pre, {\n          children: _jsx(_components.code, {\n            className: \"language-cpp\",\n            children: \"struct Edge {\\n\\tint a,b,w;\\n\\tfriend bool operator<(const Edge& x, const Edge& y) { return x.w < y.w; }\\n};\\n\"\n          })\n        }), _jsxs(_components.h3, {\n          id: \"method-2---comparison-function\",\n          children: [_jsx(_components.a, {\n            href: \"#method-2---comparison-function\",\n            \"aria-hidden\": \"true\",\n            tabIndex: \"-1\",\n            className: \"anchor before\",\n            children: _jsx(HeaderLink, {})\n          }), \"Method 2 - Comparison Function\"]\n        }), _jsx(_components.p, {\n          children: \"This works for both objects and primitives, and you can declare many different\\ncomparators for the same object.\"\n        }), _jsx(_components.pre, {\n          children: _jsx(_components.code, {\n            className: \"language-cpp\",\n            children: \"#include <bits/stdc++.h>\\nusing namespace std;\\n\\nstruct Edge {\\n\\tint a,b,w;\\n};\\n\\nbool cmp(const Edge& x, const Edge& y) { return x.w < y.w; }\\n\\nint main() {\\n\\tint M = 4;\\n\\tvector<Edge> v;\\n\\tfor (int i = 0; i < M; ++i) {\\n\\t\\tint a,b,w; cin >> a >> b >> w;\\n\\t\\tv.push_back({a,b,w});\\n\\t}\\n\\tsort(begin(v),end(v),cmp);\\n\\tfor (Edge e: v) cout << e.a << \\\" \\\" << e.b << \\\" \\\" << e.w << \\\"\\\\n\\\";\\n}\\n\"\n          })\n        }), _jsxs(_components.p, {\n          children: [\"We can also use \", _jsx(_components.a, {\n            href: \"/general/lambda\",\n            children: \"lambda expressions\"\n          }), \" in C++11 or above:\"]\n        }), _jsx(_components.pre, {\n          children: _jsx(_components.code, {\n            className: \"language-cpp\",\n            children: \"sort(begin(v),end(v),[](const Edge& x, const Edge& y) { return x.w < y.w; });\\n\"\n          })\n        })]\n      }), _jsxs(JavaSection, {\n        children: [_jsxs(_components.p, {\n          children: [\"What a \", _jsx(_components.code, {\n            children: \"Comparator\"\n          }), \" does is compare two objects as follows, based on our\\ncomparison criteria:\"]\n        }), _jsxs(_components.ul, {\n          children: [\"\\n\", _jsxs(_components.li, {\n            children: [\"If object \", _jsx(MATHSPAN, {\n              className: \"math math-inline\",\n              latex: \"x\",\n              children: \"<span class=\\\"katex\\\"><span class=\\\"katex-mathml\\\"><math xmlns=\\\"http://www.w3.org/1998/Math/MathML\\\"><semantics><mrow><mi>x</mi></mrow><annotation encoding=\\\"application/x-tex\\\">x</annotation></semantics></math></span><span class=\\\"katex-html\\\" aria-hidden=\\\"true\\\"><span class=\\\"base\\\"><span class=\\\"strut\\\" style=\\\"height:0.4306em;\\\"></span><span class=\\\"mord mathnormal\\\">x</span></span></span></span>\"\n            }), \" is less than object \", _jsx(MATHSPAN, {\n              className: \"math math-inline\",\n              latex: \"y\",\n              children: \"<span class=\\\"katex\\\"><span class=\\\"katex-mathml\\\"><math xmlns=\\\"http://www.w3.org/1998/Math/MathML\\\"><semantics><mrow><mi>y</mi></mrow><annotation encoding=\\\"application/x-tex\\\">y</annotation></semantics></math></span><span class=\\\"katex-html\\\" aria-hidden=\\\"true\\\"><span class=\\\"base\\\"><span class=\\\"strut\\\" style=\\\"height:0.625em;vertical-align:-0.1944em;\\\"></span><span class=\\\"mord mathnormal\\\" style=\\\"margin-right:0.03588em;\\\">y</span></span></span></span>\"\n            }), \", return a negative integer.\"]\n          }), \"\\n\", _jsxs(_components.li, {\n            children: [\"If object \", _jsx(MATHSPAN, {\n              className: \"math math-inline\",\n              latex: \"x\",\n              children: \"<span class=\\\"katex\\\"><span class=\\\"katex-mathml\\\"><math xmlns=\\\"http://www.w3.org/1998/Math/MathML\\\"><semantics><mrow><mi>x</mi></mrow><annotation encoding=\\\"application/x-tex\\\">x</annotation></semantics></math></span><span class=\\\"katex-html\\\" aria-hidden=\\\"true\\\"><span class=\\\"base\\\"><span class=\\\"strut\\\" style=\\\"height:0.4306em;\\\"></span><span class=\\\"mord mathnormal\\\">x</span></span></span></span>\"\n            }), \" is greater than object \", _jsx(MATHSPAN, {\n              className: \"math math-inline\",\n              latex: \"y\",\n              children: \"<span class=\\\"katex\\\"><span class=\\\"katex-mathml\\\"><math xmlns=\\\"http://www.w3.org/1998/Math/MathML\\\"><semantics><mrow><mi>y</mi></mrow><annotation encoding=\\\"application/x-tex\\\">y</annotation></semantics></math></span><span class=\\\"katex-html\\\" aria-hidden=\\\"true\\\"><span class=\\\"base\\\"><span class=\\\"strut\\\" style=\\\"height:0.625em;vertical-align:-0.1944em;\\\"></span><span class=\\\"mord mathnormal\\\" style=\\\"margin-right:0.03588em;\\\">y</span></span></span></span>\"\n            }), \", return a positive integer.\"]\n          }), \"\\n\", _jsxs(_components.li, {\n            children: [\"If object \", _jsx(MATHSPAN, {\n              className: \"math math-inline\",\n              latex: \"x\",\n              children: \"<span class=\\\"katex\\\"><span class=\\\"katex-mathml\\\"><math xmlns=\\\"http://www.w3.org/1998/Math/MathML\\\"><semantics><mrow><mi>x</mi></mrow><annotation encoding=\\\"application/x-tex\\\">x</annotation></semantics></math></span><span class=\\\"katex-html\\\" aria-hidden=\\\"true\\\"><span class=\\\"base\\\"><span class=\\\"strut\\\" style=\\\"height:0.4306em;\\\"></span><span class=\\\"mord mathnormal\\\">x</span></span></span></span>\"\n            }), \" is equal to object \", _jsx(MATHSPAN, {\n              className: \"math math-inline\",\n              latex: \"y\",\n              children: \"<span class=\\\"katex\\\"><span class=\\\"katex-mathml\\\"><math xmlns=\\\"http://www.w3.org/1998/Math/MathML\\\"><semantics><mrow><mi>y</mi></mrow><annotation encoding=\\\"application/x-tex\\\">y</annotation></semantics></math></span><span class=\\\"katex-html\\\" aria-hidden=\\\"true\\\"><span class=\\\"base\\\"><span class=\\\"strut\\\" style=\\\"height:0.625em;vertical-align:-0.1944em;\\\"></span><span class=\\\"mord mathnormal\\\" style=\\\"margin-right:0.03588em;\\\">y</span></span></span></span>\"\n            }), \", return 0.\"]\n          }), \"\\n\"]\n        }), _jsx(_components.p, {\n          children: \"In addition to returning the correct number, comparators should also satisfy the\\nfollowing conditions:\"\n        }), _jsxs(_components.ul, {\n          children: [\"\\n\", _jsxs(_components.li, {\n            children: [\"The function must be consistent with respect to reversing the order of the\\narguments: if \", _jsx(_components.code, {\n              children: \"compare(x, y)\"\n            }), \" is positive, then \", _jsx(_components.code, {\n              children: \"compare(y, x)\"\n            }), \" should be\\nnegative and vice versa.\"]\n          }), \"\\n\", _jsxs(_components.li, {\n            children: [\"The function must be transitive. If \", _jsx(_components.code, {\n              children: \"compare(x, y) > 0\"\n            }), \" and\\n\", _jsx(_components.code, {\n              children: \"compare(y, z) > 0\"\n            }), \", then \", _jsx(_components.code, {\n              children: \"compare(x, z) > 0\"\n            }), \". Same applies if the compare\\nfunctions return negative numbers.\"]\n          }), \"\\n\", _jsxs(_components.li, {\n            children: [\"Equality must be consistent. If \", _jsx(_components.code, {\n              children: \"compare(x, y) = 0\"\n            }), \", then \", _jsx(_components.code, {\n              children: \"compare(x, z)\"\n            }), \" and\\n\", _jsx(_components.code, {\n              children: \"compare(y, z)\"\n            }), \" must both be positive, both negative, or both zero. Note that\\nthey don't have to be equal, they just need to have the same sign.\"]\n          }), \"\\n\"]\n        }), _jsxs(_components.p, {\n          children: [\"Java has default functions for comparing \", _jsx(_components.code, {\n            children: \"int\"\n          }), \", \", _jsx(_components.code, {\n            children: \"long\"\n          }), \", \", _jsx(_components.code, {\n            children: \"double\"\n          }), \" types. The\\n\", _jsx(_components.code, {\n            children: \"Integer.compare()\"\n          }), \", \", _jsx(_components.code, {\n            children: \"Long.compare()\"\n          }), \", and \", _jsx(_components.code, {\n            children: \"Double.compare()\"\n          }), \" functions take two\\narguments \", _jsx(MATHSPAN, {\n            className: \"math math-inline\",\n            latex: \"x\",\n            children: \"<span class=\\\"katex\\\"><span class=\\\"katex-mathml\\\"><math xmlns=\\\"http://www.w3.org/1998/Math/MathML\\\"><semantics><mrow><mi>x</mi></mrow><annotation encoding=\\\"application/x-tex\\\">x</annotation></semantics></math></span><span class=\\\"katex-html\\\" aria-hidden=\\\"true\\\"><span class=\\\"base\\\"><span class=\\\"strut\\\" style=\\\"height:0.4306em;\\\"></span><span class=\\\"mord mathnormal\\\">x</span></span></span></span>\"\n          }), \" and \", _jsx(MATHSPAN, {\n            className: \"math math-inline\",\n            latex: \"y\",\n            children: \"<span class=\\\"katex\\\"><span class=\\\"katex-mathml\\\"><math xmlns=\\\"http://www.w3.org/1998/Math/MathML\\\"><semantics><mrow><mi>y</mi></mrow><annotation encoding=\\\"application/x-tex\\\">y</annotation></semantics></math></span><span class=\\\"katex-html\\\" aria-hidden=\\\"true\\\"><span class=\\\"base\\\"><span class=\\\"strut\\\" style=\\\"height:0.625em;vertical-align:-0.1944em;\\\"></span><span class=\\\"mord mathnormal\\\" style=\\\"margin-right:0.03588em;\\\">y</span></span></span></span>\"\n          }), \" and compare them as described above.\"]\n        }), _jsxs(_components.p, {\n          children: [\"There are two ways of implementing this in Java: \", _jsx(_components.code, {\n            children: \"Comparable\"\n          }), \", and \", _jsx(_components.code, {\n            children: \"Comparator\"\n          }), \".\\nThey essentially serve the same purpose, but \", _jsx(_components.code, {\n            children: \"Comparable\"\n          }), \" is generally easier\\nand shorter to code. \", _jsx(_components.code, {\n            children: \"Comparable\"\n          }), \" is a function implemented within the class\\ncontaining the custom object, while \", _jsx(_components.code, {\n            children: \"Comparator\"\n          }), \" is its own class.\"]\n        }), _jsxs(_components.h3, {\n          id: \"method-1---comparable\",\n          children: [_jsx(_components.a, {\n            href: \"#method-1---comparable\",\n            \"aria-hidden\": \"true\",\n            tabIndex: \"-1\",\n            className: \"anchor before\",\n            children: _jsx(HeaderLink, {})\n          }), \"Method 1 - Comparable\"]\n        }), _jsxs(_components.p, {\n          children: [\"We'll need to put \", _jsx(_components.code, {\n            children: \"implements Comparable<Edge>\"\n          }), \" into the heading of the class.\\nFurthermore, we'll need to implement the \", _jsx(_components.code, {\n            children: \"compareTo\"\n          }), \" method. Essentially,\\n\", _jsx(_components.code, {\n            children: \"compareTo(x)\"\n          }), \" is the \", _jsx(_components.code, {\n            children: \"compare\"\n          }), \" function that we described above, with the\\nobject itself as the first argument, or \", _jsx(_components.code, {\n            children: \"compare(self, x)\"\n          }), \".\"]\n        }), _jsxs(_components.p, {\n          children: [\"When using Comparable, we can just call \", _jsx(_components.code, {\n            children: \"Arrays.sort(arr)\"\n          }), \" or\\n\", _jsx(_components.code, {\n            children: \"Collections.sort(list)\"\n          }), \" on the array or list as usual.\"]\n        }), _jsx(_components.pre, {\n          children: _jsx(_components.code, {\n            className: \"language-java\",\n            children: \"import java.util.*;\\n\\npublic class Sol {\\n\\tstatic class Edge implements Comparable<Edge> {\\n\\t    int a,b,w;\\n\\t    public Edge(int _a, int _b, int _w) { a = _a; b = _b; w = _w; }\\n\\t    public int compareTo(Edge y) { return Integer.compare(w,y.w); }\\n\\t}\\n\\tpublic static void main(String[] args) {\\n\\t\\tint M = 4;\\n\\t\\tScanner in = new Scanner(System.in);\\n\\t\\tArrayList<Edge> v = new ArrayList<Edge>();\\n\\t\\tfor (int i = 0; i < M; ++i) {\\n\\t\\t\\tint a = in.nextInt();\\n\\t\\t\\tint b = in.nextInt();\\n\\t\\t\\tint w = in.nextInt();\\n\\t\\t\\tv.add(new Edge(a,b,w));\\n\\t\\t}\\n\\t\\tCollections.sort(v);\\n\\t\\tfor (Edge e: v){\\n\\t\\t\\tSystem.out.print(e.a);\\n\\t\\t\\tSystem.out.print(' ');\\n\\t\\t\\tSystem.out.print(e.b);\\n\\t\\t\\tSystem.out.print(' ');\\n\\t\\t\\tSystem.out.println(e.w);\\n\\t\\t}\\n\\t}\\n}\\n\"\n          })\n        }), _jsxs(_components.h3, {\n          id: \"method-2---comparator\",\n          children: [_jsx(_components.a, {\n            href: \"#method-2---comparator\",\n            \"aria-hidden\": \"true\",\n            tabIndex: \"-1\",\n            className: \"anchor before\",\n            children: _jsx(HeaderLink, {})\n          }), \"Method 2 - Comparator\"]\n        }), _jsxs(_components.p, {\n          children: [\"If instead we choose to use \", _jsx(_components.code, {\n            children: \"Comparator\"\n          }), \", we'll need to declare a second class\\nthat implements \", _jsx(_components.code, {\n            children: \"Comparator<Edge>\"\n          }), \":\"]\n        }), _jsx(_components.pre, {\n          children: _jsx(_components.code, {\n            className: \"language-java\",\n            children: \"import java.util.*;\\n\\npublic class Sol {\\n\\tstatic class Edge {\\n\\t    int a,b,w;\\n\\t    public Edge(int _a, int _b, int _w) { a = _a; b = _b; w = _w; }\\n\\t}\\n\\tstatic class Comp implements Comparator<Edge> {\\n\\t    public int compare(Edge a, Edge b) {\\n\\t        return Integer.compare(a.w, b.w);\\n\\t    }\\n\\t}\\n\\tpublic static void main(String[] args) {\\n\\t\\tint M = 4;\\n\\t\\tScanner in = new Scanner(System.in);\\n\\t\\tArrayList<Edge> v = new ArrayList<Edge>();\\n\\t\\tfor (int i = 0; i < M; ++i) {\\n\\t\\t\\tint a = in.nextInt();\\n\\t\\t\\tint b = in.nextInt();\\n\\t\\t\\tint w = in.nextInt();\\n\\t\\t\\tv.add(new Edge(a,b,w));\\n\\t\\t}\\n\\t\\tCollections.sort(v, new Comp());\\n\\t\\tfor (Edge e: v){\\n\\t\\t\\tSystem.out.print(e.a);\\n\\t\\t\\tSystem.out.print(' ');\\n\\t\\t\\tSystem.out.print(e.b);\\n\\t\\t\\tSystem.out.print(' ');\\n\\t\\t\\tSystem.out.println(e.w);\\n\\t\\t}\\n\\t}\\n}\\n\"\n          })\n        }), _jsxs(_components.p, {\n          children: [\"When using \", _jsx(_components.code, {\n            children: \"Comparator\"\n          }), \", the syntax for using the built-in sorting function\\nrequires a second argument: \", _jsx(_components.code, {\n            children: \"Arrays.sort(arr, new Comp())\"\n          }), \", or\\n\", _jsx(_components.code, {\n            children: \"Collections.sort(list, new Comp())\"\n          }), \".\"]\n        })]\n      }), _jsxs(PySection, {\n        children: [_jsxs(_components.h3, {\n          id: \"defining-less-than-operator\",\n          children: [_jsx(_components.a, {\n            href: \"#defining-less-than-operator\",\n            \"aria-hidden\": \"true\",\n            tabIndex: \"-1\",\n            className: \"anchor before\",\n            children: _jsx(HeaderLink, {})\n          }), \"Defining Less Than Operator\"]\n        }), _jsx(_components.pre, {\n          children: _jsx(_components.code, {\n            className: \"language-py\",\n            children: \"class Edge:\\n\\tdef __init__(self, a, b, w):\\n\\t\\tself.a = a\\n\\t\\tself.b = b\\n\\t\\tself.w = w\\n\\tdef __lt__(self, other): # lt means less than\\n\\t\\treturn self.w < other.w\\n\\nv = []\\nM = 4\\nfor i in range(M):\\n\\ta,b,w = map(int,input().split())\\n\\tv.append(Edge(a,b,w))\\nv.sort()\\nfor e in v:\\n\\tprint(e.a,e.b,e.w)\\n\"\n          })\n        }), _jsxs(_components.h3, {\n          id: \"key-function\",\n          children: [_jsx(_components.a, {\n            href: \"#key-function\",\n            \"aria-hidden\": \"true\",\n            tabIndex: \"-1\",\n            className: \"anchor before\",\n            children: _jsx(HeaderLink, {})\n          }), \"Key Function\"]\n        }), _jsx(_components.p, {\n          children: \"This method maps an object to another comparable datatype with which to be\\nsorted. This is the preferred method if you are only sorting something once. In\\nthis case we map edges to their weights.\"\n        }), _jsx(_components.pre, {\n          children: _jsx(_components.code, {\n            className: \"language-py\",\n            children: \"class Edge:\\n\\tdef __init__(self, a, b, w):\\n\\t\\tself.a = a\\n\\t\\tself.b = b\\n\\t\\tself.w = w\\n\\nv = []\\nM = 4\\nfor i in range(M):\\n\\ta,b,w = map(int,input().split())\\n\\tv.append(Edge(a,b,w))\\nv.sort(key=lambda x:x.w)\\nfor e in v:\\n\\tprint(e.a,e.b,e.w)\\n\"\n          })\n        }), _jsxs(_components.h3, {\n          id: \"comparison-function\",\n          children: [_jsx(_components.a, {\n            href: \"#comparison-function\",\n            \"aria-hidden\": \"true\",\n            tabIndex: \"-1\",\n            className: \"anchor before\",\n            children: _jsx(HeaderLink, {})\n          }), \"Comparison Function\"]\n        }), _jsxs(_components.p, {\n          children: [\"A comparison function in Python must satisfy the same properties as a comparator\\nin Java. Note that old-style cmp functions are\\n\", _jsx(_components.a, {\n            href: \"https://stackoverflow.com/questions/12749398/using-a-comparator-function-to-sort\",\n            target: \"_blank\",\n            rel: \"nofollow noopener noreferrer\",\n            children: \"no longer supported\"\n          }), \",\\nso the comparison function must be converted into a key function with\\n\", _jsx(_components.a, {\n            href: \"https://docs.python.org/2/library/functools.html\",\n            target: \"_blank\",\n            rel: \"nofollow noopener noreferrer\",\n            children: _jsx(_components.code, {\n              children: \"cmp_to_key\"\n            })\n          }), \". Most of the\\ntime, it is better to use the key function, but in the rare case that the\\ncomparison function is not easily represented as a key function, we can use\\nthis.\"]\n        }), _jsx(_components.pre, {\n          children: _jsx(_components.code, {\n            className: \"language-py\",\n            children: \"from functools import cmp_to_key\\n\\nclass Edge:\\n\\tdef __init__(self, a, b, w):\\n\\t\\tself.a = a\\n\\t\\tself.b = b\\n\\t\\tself.w = w\\n\\nv = []\\nM = 4\\nfor i in range(M):\\n\\ta,b,w = map(int,input().split())\\n\\tv.append(Edge(a,b,w))\\n\\nv.sort(key=cmp_to_key(lambda a,b: a.w-b.w))\\nfor e in v:\\n\\tprint(e.a,e.b,e.w)\\n\"\n          })\n        })]\n      })]\n    }), \"\\n\", _jsxs(_components.h2, {\n      id: \"variations\",\n      children: [_jsx(_components.a, {\n        href: \"#variations\",\n        \"aria-hidden\": \"true\",\n        tabIndex: \"-1\",\n        className: \"anchor before\",\n        children: _jsx(HeaderLink, {})\n      }), \"Variations\"]\n    }), \"\\n\", _jsxs(_components.h3, {\n      id: \"sorting-in-decreasing-order-of-weight\",\n      children: [_jsx(_components.a, {\n        href: \"#sorting-in-decreasing-order-of-weight\",\n        \"aria-hidden\": \"true\",\n        tabIndex: \"-1\",\n        className: \"anchor before\",\n        children: _jsx(HeaderLink, {})\n      }), \"Sorting in Decreasing Order of Weight\"]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"We can replace all occurrences of \", _jsx(_components.code, {\n        children: \"x.w < y.w\"\n      }), \" with \", _jsx(_components.code, {\n        children: \"x.w > y.w\"\n      }), \" in our C++ code.\\nSimilarly, we can replace all occurrences of \", _jsx(_components.code, {\n        children: \"Integer.compare(x, y)\"\n      }), \" with\\n\", _jsx(_components.code, {\n        children: \"-Integer.compare(x, y)\"\n      }), \" in our Java code. In Python, we can pass the parameter\\n\", _jsx(_components.code, {\n        children: \"reverse=True\"\n      }), \" to the \", _jsx(_components.code, {\n        children: \"sort\"\n      }), \" or \", _jsx(_components.code, {\n        children: \"sorted\"\n      }), \" function.\"]\n    }), \"\\n\", _jsxs(_components.h3, {\n      id: \"sorting-by-two-criteria\",\n      children: [_jsx(_components.a, {\n        href: \"#sorting-by-two-criteria\",\n        \"aria-hidden\": \"true\",\n        tabIndex: \"-1\",\n        className: \"anchor before\",\n        children: _jsx(HeaderLink, {})\n      }), \"Sorting by Two Criteria\"]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"Now, suppose we wanted to sort a list of \", _jsx(_components.code, {\n        children: \"Edge\"\n      }), \"s in ascending order, primarily\\nby weight and secondarily by first vertex (\", _jsx(_components.code, {\n        children: \"a\"\n      }), \"). We can do this quite similarly\\nto how we handled sorting by one criterion earlier. What the comparator function\\nneeds to do is to compare the weights if the weights are not equal, and\\notherwise compare first vertices.\"]\n    }), \"\\n\", _jsxs(LanguageSection, {\n      children: [_jsx(CPPSection, {\n        children: _jsx(_components.pre, {\n          children: _jsx(_components.code, {\n            className: \"language-cpp\",\n            children: \"struct Edge {\\n\\tint a,b,w;\\n\\tbool operator<(const Edge& y) {\\n\\t\\tif (w != y.w) return w < y.w;\\n\\t\\treturn a < y.a;\\n\\t}\\n};\\n\"\n          })\n        })\n      }), _jsx(JavaSection, {\n        children: _jsx(_components.pre, {\n          children: _jsx(_components.code, {\n            className: \"language-java\",\n            children: \"static class Edge implements Comparable<Edge> {\\n\\tint a,b,w;\\n\\tpublic Edge(int _a, int _b, int _w) { a = _a; b = _b; w = _w; }\\n\\tpublic int compareTo(Edge y) {\\n\\t\\tif (w != y.w) return Integer.compare(w,y.w);\\n\\t\\treturn Integer.compare(a,y.a);\\n\\t}\\n}\\n\"\n          })\n        })\n      }), _jsxs(PySection, {\n        children: [_jsx(_components.p, {\n          children: \"In Python, tuples have a natural order based on their elements in order. We can\\ntake advantage of this to write a comparator:\"\n        }), _jsx(_components.pre, {\n          children: _jsx(_components.code, {\n            className: \"language-py\",\n            children: \"class Edge:\\n\\tdef __init__(self, a, b, w):\\n\\t\\tself.a = a\\n\\t\\tself.b = b\\n\\t\\tself.w = w\\n\\tdef __lt__(self, other): # lt means less than\\n\\t\\treturn (self.w, self.a) < (other.w, other.a)\\n\"\n          })\n        }), _jsx(_components.p, {\n          children: \"This also gives an easy way to write a key function to sort in this way:\"\n        }), _jsx(_components.pre, {\n          children: _jsx(_components.code, {\n            className: \"language-py\",\n            children: \"edges: list[Edge]\\nedges.sort(key=lambda edge: (edge.w, edge.a))\\n\"\n          })\n        })]\n      })]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Sorting by an arbitrary number of criteria is done similarly.\"\n    }), \"\\n\", _jsxs(LanguageSection, {\n      children: [_jsx(CPPSection, {}), _jsxs(JavaSection, {\n        children: [_jsx(_components.p, {\n          children: \"With Java, we can implement a comparator for arrays of arbitrary length\\n(although this might be more confusing than creating a separate class).\"\n        }), _jsx(_components.pre, {\n          children: _jsx(_components.code, {\n            className: \"language-java\",\n            children: \"import java.util.*;\\n\\npublic class Sol {\\n\\tstatic class Comp implements Comparator<int[]> {\\n\\t\\tpublic int compare(int[] a, int[] b){\\n\\t\\t\\tfor (int i = 0; i < a.length; ++i)\\n\\t\\t\\t\\tif (a[i] != b[i]) return Integer.compare(a[i],b[i]);\\n\\t\\t\\treturn 0;\\n\\t\\t}\\n\\t}\\n\\tpublic static void main(String[] args) {\\n\\t\\tint M = 4;\\n\\t\\tScanner in = new Scanner(System.in);\\n\\t\\tArrayList<int[]> v = new ArrayList<int[]>();\\n\\t\\tfor (int i = 0; i < M; ++i) {\\n\\t\\t\\tint a = in.nextInt();\\n\\t\\t\\tint b = in.nextInt();\\n\\t\\t\\tint w = in.nextInt();\\n\\t\\t\\tv.add(new int[]{w,a,b});\\n\\t\\t}\\n\\t\\tCollections.sort(v, new Comp());\\n\\t\\tfor (int[] e: v){\\n\\t\\t\\tSystem.out.print(e[1]);\\n\\t\\t\\tSystem.out.print(' ');\\n\\t\\t\\tSystem.out.print(e[2]);\\n\\t\\t\\tSystem.out.print(' ');\\n\\t\\t\\tSystem.out.println(e[0]);\\n\\t\\t}\\n\\t}\\n}\\n\"\n          })\n        })]\n      }), _jsx(PySection, {})]\n    }), \"\\n\", _jsxs(_components.h2, {\n      id: \"coordinate-compression\",\n      children: [_jsx(_components.a, {\n        href: \"#coordinate-compression\",\n        \"aria-hidden\": \"true\",\n        tabIndex: \"-1\",\n        className: \"anchor before\",\n        children: _jsx(HeaderLink, {})\n      }), \"Coordinate Compression\"]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"Coordinate compression describes the process of mapping each value in a list to its index if that\\nlist was sorted. For example, the list \", _jsx(MATHSPAN, {\n        className: \"math math-inline\",\n        latex: \"\\\\{7, 3, 4, 1\\\\}\",\n        children: \"<span class=\\\"katex\\\"><span class=\\\"katex-mathml\\\"><math xmlns=\\\"http://www.w3.org/1998/Math/MathML\\\"><semantics><mrow><mo stretchy=\\\"false\\\">{</mo><mn>7</mn><mo separator=\\\"true\\\">,</mo><mn>3</mn><mo separator=\\\"true\\\">,</mo><mn>4</mn><mo separator=\\\"true\\\">,</mo><mn>1</mn><mo stretchy=\\\"false\\\">}</mo></mrow><annotation encoding=\\\"application/x-tex\\\">\\\\{7, 3, 4, 1\\\\}</annotation></semantics></math></span><span class=\\\"katex-html\\\" aria-hidden=\\\"true\\\"><span class=\\\"base\\\"><span class=\\\"strut\\\" style=\\\"height:1em;vertical-align:-0.25em;\\\"></span><span class=\\\"mopen\\\">{</span><span class=\\\"mord\\\">7</span><span class=\\\"mpunct\\\">,</span><span class=\\\"mspace\\\" style=\\\"margin-right:0.1667em;\\\"></span><span class=\\\"mord\\\">3</span><span class=\\\"mpunct\\\">,</span><span class=\\\"mspace\\\" style=\\\"margin-right:0.1667em;\\\"></span><span class=\\\"mord\\\">4</span><span class=\\\"mpunct\\\">,</span><span class=\\\"mspace\\\" style=\\\"margin-right:0.1667em;\\\"></span><span class=\\\"mord\\\">1</span><span class=\\\"mclose\\\">}</span></span></span></span>\"\n      }), \" would be compressed to\\n\", _jsx(MATHSPAN, {\n        className: \"math math-inline\",\n        latex: \"\\\\{3, 1, 2, 0\\\\}\",\n        children: \"<span class=\\\"katex\\\"><span class=\\\"katex-mathml\\\"><math xmlns=\\\"http://www.w3.org/1998/Math/MathML\\\"><semantics><mrow><mo stretchy=\\\"false\\\">{</mo><mn>3</mn><mo separator=\\\"true\\\">,</mo><mn>1</mn><mo separator=\\\"true\\\">,</mo><mn>2</mn><mo separator=\\\"true\\\">,</mo><mn>0</mn><mo stretchy=\\\"false\\\">}</mo></mrow><annotation encoding=\\\"application/x-tex\\\">\\\\{3, 1, 2, 0\\\\}</annotation></semantics></math></span><span class=\\\"katex-html\\\" aria-hidden=\\\"true\\\"><span class=\\\"base\\\"><span class=\\\"strut\\\" style=\\\"height:1em;vertical-align:-0.25em;\\\"></span><span class=\\\"mopen\\\">{</span><span class=\\\"mord\\\">3</span><span class=\\\"mpunct\\\">,</span><span class=\\\"mspace\\\" style=\\\"margin-right:0.1667em;\\\"></span><span class=\\\"mord\\\">1</span><span class=\\\"mpunct\\\">,</span><span class=\\\"mspace\\\" style=\\\"margin-right:0.1667em;\\\"></span><span class=\\\"mord\\\">2</span><span class=\\\"mpunct\\\">,</span><span class=\\\"mspace\\\" style=\\\"margin-right:0.1667em;\\\"></span><span class=\\\"mord\\\">0</span><span class=\\\"mclose\\\">}</span></span></span></span>\"\n      }), \". Notice that \", _jsx(MATHSPAN, {\n        className: \"math math-inline\",\n        latex: \"1\",\n        children: \"<span class=\\\"katex\\\"><span class=\\\"katex-mathml\\\"><math xmlns=\\\"http://www.w3.org/1998/Math/MathML\\\"><semantics><mrow><mn>1</mn></mrow><annotation encoding=\\\"application/x-tex\\\">1</annotation></semantics></math></span><span class=\\\"katex-html\\\" aria-hidden=\\\"true\\\"><span class=\\\"base\\\"><span class=\\\"strut\\\" style=\\\"height:0.6444em;\\\"></span><span class=\\\"mord\\\">1</span></span></span></span>\"\n      }), \" is the least value in the first list, so it\\nbecomes \", _jsx(MATHSPAN, {\n        className: \"math math-inline\",\n        latex: \"0\",\n        children: \"<span class=\\\"katex\\\"><span class=\\\"katex-mathml\\\"><math xmlns=\\\"http://www.w3.org/1998/Math/MathML\\\"><semantics><mrow><mn>0</mn></mrow><annotation encoding=\\\"application/x-tex\\\">0</annotation></semantics></math></span><span class=\\\"katex-html\\\" aria-hidden=\\\"true\\\"><span class=\\\"base\\\"><span class=\\\"strut\\\" style=\\\"height:0.6444em;\\\"></span><span class=\\\"mord\\\">0</span></span></span></span>\"\n      }), \", and \", _jsx(MATHSPAN, {\n        className: \"math math-inline\",\n        latex: \"7\",\n        children: \"<span class=\\\"katex\\\"><span class=\\\"katex-mathml\\\"><math xmlns=\\\"http://www.w3.org/1998/Math/MathML\\\"><semantics><mrow><mn>7</mn></mrow><annotation encoding=\\\"application/x-tex\\\">7</annotation></semantics></math></span><span class=\\\"katex-html\\\" aria-hidden=\\\"true\\\"><span class=\\\"base\\\"><span class=\\\"strut\\\" style=\\\"height:0.6444em;\\\"></span><span class=\\\"mord\\\">7</span></span></span></span>\"\n      }), \" is the greatest value, so it becomes \", _jsx(MATHSPAN, {\n        className: \"math math-inline\",\n        latex: \"3\",\n        children: \"<span class=\\\"katex\\\"><span class=\\\"katex-mathml\\\"><math xmlns=\\\"http://www.w3.org/1998/Math/MathML\\\"><semantics><mrow><mn>3</mn></mrow><annotation encoding=\\\"application/x-tex\\\">3</annotation></semantics></math></span><span class=\\\"katex-html\\\" aria-hidden=\\\"true\\\"><span class=\\\"base\\\"><span class=\\\"strut\\\" style=\\\"height:0.6444em;\\\"></span><span class=\\\"mord\\\">3</span></span></span></span>\"\n      }), \", the largest index\\nin the list.\"]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"When we have values from a large range, but we\\nonly care about their relative order (for example, if we have to know if one\\nvalue is above another), coordinate compression is a simple way to help\\nwith implementation. For example, if we have a set of integers ranging from \", _jsx(MATHSPAN, {\n        className: \"math math-inline\",\n        latex: \"0\",\n        children: \"<span class=\\\"katex\\\"><span class=\\\"katex-mathml\\\"><math xmlns=\\\"http://www.w3.org/1998/Math/MathML\\\"><semantics><mrow><mn>0</mn></mrow><annotation encoding=\\\"application/x-tex\\\">0</annotation></semantics></math></span><span class=\\\"katex-html\\\" aria-hidden=\\\"true\\\"><span class=\\\"base\\\"><span class=\\\"strut\\\" style=\\\"height:0.6444em;\\\"></span><span class=\\\"mord\\\">0</span></span></span></span>\"\n      }), \" to \", _jsx(MATHSPAN, {\n        className: \"math math-inline\",\n        latex: \"10^9\",\n        children: \"<span class=\\\"katex\\\"><span class=\\\"katex-mathml\\\"><math xmlns=\\\"http://www.w3.org/1998/Math/MathML\\\"><semantics><mrow><mn>1</mn><msup><mn>0</mn><mn>9</mn></msup></mrow><annotation encoding=\\\"application/x-tex\\\">10^9</annotation></semantics></math></span><span class=\\\"katex-html\\\" aria-hidden=\\\"true\\\"><span class=\\\"base\\\"><span class=\\\"strut\\\" style=\\\"height:0.8141em;\\\"></span><span class=\\\"mord\\\">1</span><span class=\\\"mord\\\"><span class=\\\"mord\\\">0</span><span class=\\\"msupsub\\\"><span class=\\\"vlist-t\\\"><span class=\\\"vlist-r\\\"><span class=\\\"vlist\\\" style=\\\"height:0.8141em;\\\"><span style=\\\"top:-3.063em;margin-right:0.05em;\\\"><span class=\\\"pstrut\\\" style=\\\"height:2.7em;\\\"></span><span class=\\\"sizing reset-size6 size3 mtight\\\"><span class=\\\"mord mtight\\\">9</span></span></span></span></span></span></span></span></span></span></span>\"\n      }), \", we\\ncan't use them as array indices because we'd have to create an array of size\\n\", _jsx(MATHSPAN, {\n        className: \"math math-inline\",\n        latex: \"10^9\",\n        children: \"<span class=\\\"katex\\\"><span class=\\\"katex-mathml\\\"><math xmlns=\\\"http://www.w3.org/1998/Math/MathML\\\"><semantics><mrow><mn>1</mn><msup><mn>0</mn><mn>9</mn></msup></mrow><annotation encoding=\\\"application/x-tex\\\">10^9</annotation></semantics></math></span><span class=\\\"katex-html\\\" aria-hidden=\\\"true\\\"><span class=\\\"base\\\"><span class=\\\"strut\\\" style=\\\"height:0.8141em;\\\"></span><span class=\\\"mord\\\">1</span><span class=\\\"mord\\\"><span class=\\\"mord\\\">0</span><span class=\\\"msupsub\\\"><span class=\\\"vlist-t\\\"><span class=\\\"vlist-r\\\"><span class=\\\"vlist\\\" style=\\\"height:0.8141em;\\\"><span style=\\\"top:-3.063em;margin-right:0.05em;\\\"><span class=\\\"pstrut\\\" style=\\\"height:2.7em;\\\"></span><span class=\\\"sizing reset-size6 size3 mtight\\\"><span class=\\\"mord mtight\\\">9</span></span></span></span></span></span></span></span></span></span></span>\"\n      }), \", which would surely cause a \", _jsx(_components.code, {\n        children: \"Memory Limit Exceeded\"\n      }), \" verdict. However, if\\nthere are only \", _jsx(MATHSPAN, {\n        className: \"math math-inline\",\n        latex: \"N \\\\leq 10^6\",\n        children: \"<span class=\\\"katex\\\"><span class=\\\"katex-mathml\\\"><math xmlns=\\\"http://www.w3.org/1998/Math/MathML\\\"><semantics><mrow><mi>N</mi><mo>≤</mo><mn>1</mn><msup><mn>0</mn><mn>6</mn></msup></mrow><annotation encoding=\\\"application/x-tex\\\">N \\\\leq 10^6</annotation></semantics></math></span><span class=\\\"katex-html\\\" aria-hidden=\\\"true\\\"><span class=\\\"base\\\"><span class=\\\"strut\\\" style=\\\"height:0.8193em;vertical-align:-0.136em;\\\"></span><span class=\\\"mord mathnormal\\\" style=\\\"margin-right:0.10903em;\\\">N</span><span class=\\\"mspace\\\" style=\\\"margin-right:0.2778em;\\\"></span><span class=\\\"mrel\\\">≤</span><span class=\\\"mspace\\\" style=\\\"margin-right:0.2778em;\\\"></span></span><span class=\\\"base\\\"><span class=\\\"strut\\\" style=\\\"height:0.8141em;\\\"></span><span class=\\\"mord\\\">1</span><span class=\\\"mord\\\"><span class=\\\"mord\\\">0</span><span class=\\\"msupsub\\\"><span class=\\\"vlist-t\\\"><span class=\\\"vlist-r\\\"><span class=\\\"vlist\\\" style=\\\"height:0.8141em;\\\"><span style=\\\"top:-3.063em;margin-right:0.05em;\\\"><span class=\\\"pstrut\\\" style=\\\"height:2.7em;\\\"></span><span class=\\\"sizing reset-size6 size3 mtight\\\"><span class=\\\"mord mtight\\\">6</span></span></span></span></span></span></span></span></span></span></span>\"\n      }), \" such integers, we can coordinate-compress their\\nvalues, which guarantees that the values will all be in the range from \", _jsx(MATHSPAN, {\n        className: \"math math-inline\",\n        latex: \"0\",\n        children: \"<span class=\\\"katex\\\"><span class=\\\"katex-mathml\\\"><math xmlns=\\\"http://www.w3.org/1998/Math/MathML\\\"><semantics><mrow><mn>0</mn></mrow><annotation encoding=\\\"application/x-tex\\\">0</annotation></semantics></math></span><span class=\\\"katex-html\\\" aria-hidden=\\\"true\\\"><span class=\\\"base\\\"><span class=\\\"strut\\\" style=\\\"height:0.6444em;\\\"></span><span class=\\\"mord\\\">0</span></span></span></span>\"\n      }), \" to\\n\", _jsx(MATHSPAN, {\n        className: \"math math-inline\",\n        latex: \"N-1\",\n        children: \"<span class=\\\"katex\\\"><span class=\\\"katex-mathml\\\"><math xmlns=\\\"http://www.w3.org/1998/Math/MathML\\\"><semantics><mrow><mi>N</mi><mo>−</mo><mn>1</mn></mrow><annotation encoding=\\\"application/x-tex\\\">N-1</annotation></semantics></math></span><span class=\\\"katex-html\\\" aria-hidden=\\\"true\\\"><span class=\\\"base\\\"><span class=\\\"strut\\\" style=\\\"height:0.7667em;vertical-align:-0.0833em;\\\"></span><span class=\\\"mord mathnormal\\\" style=\\\"margin-right:0.10903em;\\\">N</span><span class=\\\"mspace\\\" style=\\\"margin-right:0.2222em;\\\"></span><span class=\\\"mbin\\\">−</span><span class=\\\"mspace\\\" style=\\\"margin-right:0.2222em;\\\"></span></span><span class=\\\"base\\\"><span class=\\\"strut\\\" style=\\\"height:0.6444em;\\\"></span><span class=\\\"mord\\\">1</span></span></span></span>\"\n      }), \", which \", _jsx(_components.em, {\n        children: \"can\"\n      }), \" be used as array indices.\"]\n    }), \"\\n\", _jsx(FocusProblem, {\n      problem: \"sample2\"\n    }), \"\\n\", _jsxs(_components.h3, {\n      id: \"example-1\",\n      children: [_jsx(_components.a, {\n        href: \"#example-1\",\n        \"aria-hidden\": \"true\",\n        tabIndex: \"-1\",\n        className: \"anchor before\",\n        children: _jsx(HeaderLink, {})\n      }), \"Example 1\"]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"A good example of coordinate compression in action is in the solution of \", _jsx(_components.em, {\n        children: \"USACO\\nRectangular Pasture.\"\n      }), \" Again, we won't delve into the full solution but instead\\ndiscuss how coordinate compression is applied. Since the solution uses\\n\", _jsx(_components.a, {\n        href: \"/silver/prefix-sums-2\",\n        children: \"2D-prefix\"\n      }), \" sums (another Silver topic), it is helpful if\\nall point coordinates are coordinate-compressed to the range \", _jsx(MATHSPAN, {\n        className: \"math math-inline\",\n        latex: \"0\",\n        children: \"<span class=\\\"katex\\\"><span class=\\\"katex-mathml\\\"><math xmlns=\\\"http://www.w3.org/1998/Math/MathML\\\"><semantics><mrow><mn>0</mn></mrow><annotation encoding=\\\"application/x-tex\\\">0</annotation></semantics></math></span><span class=\\\"katex-html\\\" aria-hidden=\\\"true\\\"><span class=\\\"base\\\"><span class=\\\"strut\\\" style=\\\"height:0.6444em;\\\"></span><span class=\\\"mord\\\">0</span></span></span></span>\"\n      }), \" to \", _jsx(MATHSPAN, {\n        className: \"math math-inline\",\n        latex: \"N-1\",\n        children: \"<span class=\\\"katex\\\"><span class=\\\"katex-mathml\\\"><math xmlns=\\\"http://www.w3.org/1998/Math/MathML\\\"><semantics><mrow><mi>N</mi><mo>−</mo><mn>1</mn></mrow><annotation encoding=\\\"application/x-tex\\\">N-1</annotation></semantics></math></span><span class=\\\"katex-html\\\" aria-hidden=\\\"true\\\"><span class=\\\"base\\\"><span class=\\\"strut\\\" style=\\\"height:0.7667em;vertical-align:-0.0833em;\\\"></span><span class=\\\"mord mathnormal\\\" style=\\\"margin-right:0.10903em;\\\">N</span><span class=\\\"mspace\\\" style=\\\"margin-right:0.2222em;\\\"></span><span class=\\\"mbin\\\">−</span><span class=\\\"mspace\\\" style=\\\"margin-right:0.2222em;\\\"></span></span><span class=\\\"base\\\"><span class=\\\"strut\\\" style=\\\"height:0.6444em;\\\"></span><span class=\\\"mord\\\">1</span></span></span></span>\"\n      }), \" so\\nthey can be used as array indices. Without coordinate compression, creating a large enough array would result in a \", _jsx(_components.code, {\n        children: \"Memory Limit Exceeded\"\n      }), \" verdict.\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Below you will find the solution to Rectangular Pasture, which uses\\ncoordinate compression at the beginning. Observe how a custom comparator is used to sort the\\npoints:\"\n    }), \"\\n\", _jsxs(LanguageSection, {\n      children: [_jsx(CPPSection, {\n        children: _jsx(_components.pre, {\n          children: _jsx(_components.code, {\n            className: \"language-cpp\",\n            children: \"//BeginCodeSnip{Solution code}\\n#include <iostream>\\n#include <algorithm>\\nusing namespace std;\\n//EndCodeSnip\\n\\ntypedef pair<int,int> Point;\\nbool ycomp(Point p, Point q) { return p.second < q.second; }\\n\\n//BeginCodeSnip{Solution code}\\nconst int MAX_N = 2500;\\nint N, Psum[MAX_N+1][MAX_N+1];\\nPoint P[MAX_N];\\n\\nint rsum(int x1, int y1, int x2, int y2)\\n{\\n\\treturn Psum[x2+1][y2+1] - Psum[x2+1][y1] - Psum[x1][y2+1] + Psum[x1][y1];\\n}\\n\\nint main(void)\\n{\\n\\tcin >> N;\\n\\tfor (int i=0; i<N; i++) {\\n\\t\\tint x, y;\\n\\t\\tcin >> x >> y;\\n\\t\\tP[i] = make_pair(x,y);\\n\\t}\\n//EndCodeSnip\\n\\n\\tsort(P, P+N);\\n\\tfor (int i=0; i<N; i++) P[i].first = i+1;\\n\\tsort(P, P+N, ycomp);\\n\\tfor (int i=0; i<N; i++) P[i].second = i+1;\\n\\n//BeginCodeSnip{Solution code}\\n\\tfor (int i=0; i<N; i++) Psum[P[i].first][P[i].second] = 1;\\n\\tfor (int i=1; i<=N; i++)\\n\\t\\tfor (int j=1; j<=N; j++)\\n\\t\\t\\tPsum[i][j] += Psum[i-1][j] + Psum[i][j-1] - Psum[i-1][j-1];\\n\\tlong long answer = 0;\\n\\tfor (int i=0; i<N; i++)\\n\\t\\tfor (int j=i; j<N; j++) {\\n\\t\\t\\tint x1 = min(P[i].first, P[j].first) - 1;\\n\\t\\t\\tint x2 = max(P[i].first, P[j].first) - 1;\\n\\t\\t\\tanswer += rsum(0,i,x1,j) * rsum(x2,i,N-1,j);\\n\\t\\t}\\n\\tcout << answer + 1 << \\\"\\\\n\\\";\\n\\n}\\n//EndCodeSnip\\n\"\n          })\n        })\n      }), _jsxs(JavaSection, {\n        children: [_jsx(_components.pre, {\n          children: _jsx(_components.code, {\n            className: \"language-java\",\n            children: \"//BeginCodeSnip{Solution code}\\nimport java.util.Arrays;\\nimport java.util.Comparator;\\nimport java.util.Scanner;\\n\\npublic class RectangularPasture {\\n\\tstatic int[][] sums;\\n\\n\\tstatic int getSum(int fromX, int toX, int fromY, int toY) {\\n\\t\\treturn sums[toX][toY] - sums[fromX - 1][toY] - sums[toX][fromY - 1] + sums[fromX - 1][fromY - 1];\\n\\t}\\n\\n\\tpublic static void main(String[] args) {\\n\\t\\tScanner in = new Scanner(System.in);\\n\\t\\tint n = in.nextInt();\\n\\t\\t//EndCodeSnip\\n\\n\\t\\tint[] xs = new int[n];\\n\\t\\tint[] ys = new int[n];\\n\\n\\t\\tInteger[] cows = new Integer[n];\\n\\t\\tfor (int j = 0; j < n; j++) {\\n\\t\\t\\txs[j] = in.nextInt();\\n\\t\\t\\tys[j] = in.nextInt();\\n\\t\\t\\tcows[j] = j;\\n\\t\\t}\\n\\n\\t\\tArrays.sort(cows, Comparator.comparingInt(j -> xs[j]));\\n\\t\\tfor (int x = 1; x <= n; x++) {\\n\\t\\t\\txs[cows[x - 1]] = x;\\n\\t\\t}\\n\\t\\tArrays.sort(cows, Comparator.comparingInt(j -> ys[j]));\\n\\t\\tfor (int y = 1; y <= n; y++) {\\n\\t\\t\\tys[cows[y - 1]] = y;\\n\\t\\t}\\n\\n//BeginCodeSnip{Solution code}\\n\\t\\tsums = new int[n + 1][n + 1];\\n\\t\\tfor (int j = 0; j < n; j++) {\\n\\t\\t\\tsums[xs[j]][ys[j]]++;\\n\\t\\t}\\n\\t\\tfor (int x = 0; x <= n; x++) {\\n\\t\\t\\tfor (int y = 0; y <= n; y++) {\\n\\t\\t\\t\\tif (x > 0) {\\n\\t\\t\\t\\t\\tsums[x][y] += sums[x - 1][y];\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tif (y > 0) {\\n\\t\\t\\t\\t\\tsums[x][y] += sums[x][y - 1];\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tif (x > 0 && y > 0) {\\n\\t\\t\\t\\t\\tsums[x][y] -= sums[x - 1][y - 1];\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tlong answer = n + 1;\\n\\t\\tfor (int j = 0; j < n; j++) {\\n\\t\\t\\tfor (int k = j + 1; k < n; k++) {\\n\\t\\t\\t\\tanswer += getSum(Math.min(xs[j], xs[k]), Math.max(xs[j], xs[k]), 1, Math.min(ys[j], ys[k]))\\n\\t\\t\\t\\t\\t* getSum(Math.min(xs[j], xs[k]), Math.max(xs[j], xs[k]), Math.max(ys[j], ys[k]), n);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tSystem.out.println(answer);\\n\\t}\\n}\\n//EndCodeSnip\\n\"\n          })\n        }), _jsxs(_components.p, {\n          children: [\"The solution uses a \", _jsx(_components.a, {\n            href: \"https://docs.oracle.com/javase/tutorial/java/javaOO/lambdaexpressions.html\",\n            target: \"_blank\",\n            rel: \"nofollow noopener noreferrer\",\n            children: \"lambda\"\n          }), \" function as the custom comparator, which our guide\\ndidn't discuss, but it should be apparent which coordinate (\", _jsx(_components.code, {\n            children: \"x\"\n          }), \" or \", _jsx(_components.code, {\n            children: \"y\"\n          }), \") that the\\ncomparator is sorting by.\"]\n        })]\n      })]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"The solution to Rectangular Pasture directly replaces coordinates with their compressed values, and forgets the real values of the coordinates because they are unnecessary. However, there may be problems for which we need to also remember the original values of coordinates that we compress.\"\n    }), \"\\n\", _jsxs(_components.h3, {\n      id: \"example-2\",\n      children: [_jsx(_components.a, {\n        href: \"#example-2\",\n        \"aria-hidden\": \"true\",\n        tabIndex: \"-1\",\n        className: \"anchor before\",\n        children: _jsx(HeaderLink, {})\n      }), \"Example 2\"]\n    }), \"\\n\", _jsx(FocusProblem, {\n      problem: \"sample3\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"This problem will require prefix sums and coordinate compression. However, the implementation of coordinate compression in this solution will also require remembering values in addition to compressing them (as opposed to just replacing the original values, as in the last problem). If you just want to focus on the implementation of coordinate compression and how it can switch between compressed indices and original values, see the contracted code below. \", _jsx(_components.code, {\n        children: \"indices\"\n      }), \" is a list of values that need to be compressed. After it gets sorted and has duplicate values removed, it is ready to use. The method \", _jsx(_components.code, {\n        children: \"getCompressedIndex\"\n      }), \" takes in an original value, and \", _jsx(_components.a, {\n        href: \"/silver/binary-search\",\n        children: \"binary searches\"\n      }), \" for its position in \", _jsx(_components.code, {\n        children: \"indices\"\n      }), \" to get its corresponding compressed index. To go from a compressed index to an original value, the code can just access that index in \", _jsx(_components.code, {\n        children: \"indices\"\n      }), \".\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"We also provide a full solution:\"\n    }), \"\\n\", _jsxs(Spoiler, {\n      title: \"Full Solution\",\n      children: [_jsxs(_components.p, {\n        children: [\"First of all, let's figure out the value at each index in array \", _jsx(MATHSPAN, {\n          className: \"math math-inline\",\n          latex: \"a\",\n          children: \"<span class=\\\"katex\\\"><span class=\\\"katex-mathml\\\"><math xmlns=\\\"http://www.w3.org/1998/Math/MathML\\\"><semantics><mrow><mi>a</mi></mrow><annotation encoding=\\\"application/x-tex\\\">a</annotation></semantics></math></span><span class=\\\"katex-html\\\" aria-hidden=\\\"true\\\"><span class=\\\"base\\\"><span class=\\\"strut\\\" style=\\\"height:0.4306em;\\\"></span><span class=\\\"mord mathnormal\\\">a</span></span></span></span>\"\n        }), \". It would be too slow to loop through every index in every update interval as well as every index in a query interval (The time complexity would be \", _jsx(MATHSPAN, {\n          className: \"math math-inline\",\n          latex: \"O(N \\\\cdot max_c + Q \\\\cdot max_c)\",\n          children: \"<span class=\\\"katex\\\"><span class=\\\"katex-mathml\\\"><math xmlns=\\\"http://www.w3.org/1998/Math/MathML\\\"><semantics><mrow><mi>O</mi><mo stretchy=\\\"false\\\">(</mo><mi>N</mi><mo>⋅</mo><mi>m</mi><mi>a</mi><msub><mi>x</mi><mi>c</mi></msub><mo>+</mo><mi>Q</mi><mo>⋅</mo><mi>m</mi><mi>a</mi><msub><mi>x</mi><mi>c</mi></msub><mo stretchy=\\\"false\\\">)</mo></mrow><annotation encoding=\\\"application/x-tex\\\">O(N \\\\cdot max_c + Q \\\\cdot max_c)</annotation></semantics></math></span><span class=\\\"katex-html\\\" aria-hidden=\\\"true\\\"><span class=\\\"base\\\"><span class=\\\"strut\\\" style=\\\"height:1em;vertical-align:-0.25em;\\\"></span><span class=\\\"mord mathnormal\\\" style=\\\"margin-right:0.02778em;\\\">O</span><span class=\\\"mopen\\\">(</span><span class=\\\"mord mathnormal\\\" style=\\\"margin-right:0.10903em;\\\">N</span><span class=\\\"mspace\\\" style=\\\"margin-right:0.2222em;\\\"></span><span class=\\\"mbin\\\">⋅</span><span class=\\\"mspace\\\" style=\\\"margin-right:0.2222em;\\\"></span></span><span class=\\\"base\\\"><span class=\\\"strut\\\" style=\\\"height:0.7333em;vertical-align:-0.15em;\\\"></span><span class=\\\"mord mathnormal\\\">ma</span><span class=\\\"mord\\\"><span class=\\\"mord mathnormal\\\">x</span><span class=\\\"msupsub\\\"><span class=\\\"vlist-t vlist-t2\\\"><span class=\\\"vlist-r\\\"><span class=\\\"vlist\\\" style=\\\"height:0.1514em;\\\"><span style=\\\"top:-2.55em;margin-left:0em;margin-right:0.05em;\\\"><span class=\\\"pstrut\\\" style=\\\"height:2.7em;\\\"></span><span class=\\\"sizing reset-size6 size3 mtight\\\"><span class=\\\"mord mathnormal mtight\\\">c</span></span></span></span><span class=\\\"vlist-s\\\">​</span></span><span class=\\\"vlist-r\\\"><span class=\\\"vlist\\\" style=\\\"height:0.15em;\\\"><span></span></span></span></span></span></span><span class=\\\"mspace\\\" style=\\\"margin-right:0.2222em;\\\"></span><span class=\\\"mbin\\\">+</span><span class=\\\"mspace\\\" style=\\\"margin-right:0.2222em;\\\"></span></span><span class=\\\"base\\\"><span class=\\\"strut\\\" style=\\\"height:0.8778em;vertical-align:-0.1944em;\\\"></span><span class=\\\"mord mathnormal\\\">Q</span><span class=\\\"mspace\\\" style=\\\"margin-right:0.2222em;\\\"></span><span class=\\\"mbin\\\">⋅</span><span class=\\\"mspace\\\" style=\\\"margin-right:0.2222em;\\\"></span></span><span class=\\\"base\\\"><span class=\\\"strut\\\" style=\\\"height:1em;vertical-align:-0.25em;\\\"></span><span class=\\\"mord mathnormal\\\">ma</span><span class=\\\"mord\\\"><span class=\\\"mord mathnormal\\\">x</span><span class=\\\"msupsub\\\"><span class=\\\"vlist-t vlist-t2\\\"><span class=\\\"vlist-r\\\"><span class=\\\"vlist\\\" style=\\\"height:0.1514em;\\\"><span style=\\\"top:-2.55em;margin-left:0em;margin-right:0.05em;\\\"><span class=\\\"pstrut\\\" style=\\\"height:2.7em;\\\"></span><span class=\\\"sizing reset-size6 size3 mtight\\\"><span class=\\\"mord mathnormal mtight\\\">c</span></span></span></span><span class=\\\"vlist-s\\\">​</span></span><span class=\\\"vlist-r\\\"><span class=\\\"vlist\\\" style=\\\"height:0.15em;\\\"><span></span></span></span></span></span></span><span class=\\\"mclose\\\">)</span></span></span></span>\"\n        }), \" where \", _jsx(MATHSPAN, {\n          className: \"math math-inline\",\n          latex: \"max_c\",\n          children: \"<span class=\\\"katex\\\"><span class=\\\"katex-mathml\\\"><math xmlns=\\\"http://www.w3.org/1998/Math/MathML\\\"><semantics><mrow><mi>m</mi><mi>a</mi><msub><mi>x</mi><mi>c</mi></msub></mrow><annotation encoding=\\\"application/x-tex\\\">max_c</annotation></semantics></math></span><span class=\\\"katex-html\\\" aria-hidden=\\\"true\\\"><span class=\\\"base\\\"><span class=\\\"strut\\\" style=\\\"height:0.5806em;vertical-align:-0.15em;\\\"></span><span class=\\\"mord mathnormal\\\">ma</span><span class=\\\"mord\\\"><span class=\\\"mord mathnormal\\\">x</span><span class=\\\"msupsub\\\"><span class=\\\"vlist-t vlist-t2\\\"><span class=\\\"vlist-r\\\"><span class=\\\"vlist\\\" style=\\\"height:0.1514em;\\\"><span style=\\\"top:-2.55em;margin-left:0em;margin-right:0.05em;\\\"><span class=\\\"pstrut\\\" style=\\\"height:2.7em;\\\"></span><span class=\\\"sizing reset-size6 size3 mtight\\\"><span class=\\\"mord mathnormal mtight\\\">c</span></span></span></span><span class=\\\"vlist-s\\\">​</span></span><span class=\\\"vlist-r\\\"><span class=\\\"vlist\\\" style=\\\"height:0.15em;\\\"><span></span></span></span></span></span></span></span></span></span>\"\n        }), \" is the maximum coordinate given in the input, which is up to \", _jsx(MATHSPAN, {\n          className: \"math math-inline\",\n          latex: \"10^9\",\n          children: \"<span class=\\\"katex\\\"><span class=\\\"katex-mathml\\\"><math xmlns=\\\"http://www.w3.org/1998/Math/MathML\\\"><semantics><mrow><mn>1</mn><msup><mn>0</mn><mn>9</mn></msup></mrow><annotation encoding=\\\"application/x-tex\\\">10^9</annotation></semantics></math></span><span class=\\\"katex-html\\\" aria-hidden=\\\"true\\\"><span class=\\\"base\\\"><span class=\\\"strut\\\" style=\\\"height:0.8141em;\\\"></span><span class=\\\"mord\\\">1</span><span class=\\\"mord\\\"><span class=\\\"mord\\\">0</span><span class=\\\"msupsub\\\"><span class=\\\"vlist-t\\\"><span class=\\\"vlist-r\\\"><span class=\\\"vlist\\\" style=\\\"height:0.8141em;\\\"><span style=\\\"top:-3.063em;margin-right:0.05em;\\\"><span class=\\\"pstrut\\\" style=\\\"height:2.7em;\\\"></span><span class=\\\"sizing reset-size6 size3 mtight\\\"><span class=\\\"mord mtight\\\">9</span></span></span></span></span></span></span></span></span></span></span>\"\n        }), \".). At the same time, that approach would take \", _jsx(MATHSPAN, {\n          className: \"math math-inline\",\n          latex: \"O(max_c)\",\n          children: \"<span class=\\\"katex\\\"><span class=\\\"katex-mathml\\\"><math xmlns=\\\"http://www.w3.org/1998/Math/MathML\\\"><semantics><mrow><mi>O</mi><mo stretchy=\\\"false\\\">(</mo><mi>m</mi><mi>a</mi><msub><mi>x</mi><mi>c</mi></msub><mo stretchy=\\\"false\\\">)</mo></mrow><annotation encoding=\\\"application/x-tex\\\">O(max_c)</annotation></semantics></math></span><span class=\\\"katex-html\\\" aria-hidden=\\\"true\\\"><span class=\\\"base\\\"><span class=\\\"strut\\\" style=\\\"height:1em;vertical-align:-0.25em;\\\"></span><span class=\\\"mord mathnormal\\\" style=\\\"margin-right:0.02778em;\\\">O</span><span class=\\\"mopen\\\">(</span><span class=\\\"mord mathnormal\\\">ma</span><span class=\\\"mord\\\"><span class=\\\"mord mathnormal\\\">x</span><span class=\\\"msupsub\\\"><span class=\\\"vlist-t vlist-t2\\\"><span class=\\\"vlist-r\\\"><span class=\\\"vlist\\\" style=\\\"height:0.1514em;\\\"><span style=\\\"top:-2.55em;margin-left:0em;margin-right:0.05em;\\\"><span class=\\\"pstrut\\\" style=\\\"height:2.7em;\\\"></span><span class=\\\"sizing reset-size6 size3 mtight\\\"><span class=\\\"mord mathnormal mtight\\\">c</span></span></span></span><span class=\\\"vlist-s\\\">​</span></span><span class=\\\"vlist-r\\\"><span class=\\\"vlist\\\" style=\\\"height:0.15em;\\\"><span></span></span></span></span></span></span><span class=\\\"mclose\\\">)</span></span></span></span>\"\n        }), \" memory, which is also too much. Instead, we make an observation that will make prefix sums paired with coordinate compression a viable option.\"]\n      }), _jsxs(_components.p, {\n        children: [\"Not every index in the whole range from \", _jsx(MATHSPAN, {\n          className: \"math math-inline\",\n          latex: \"1...10^9\",\n          children: \"<span class=\\\"katex\\\"><span class=\\\"katex-mathml\\\"><math xmlns=\\\"http://www.w3.org/1998/Math/MathML\\\"><semantics><mrow><mn>1...1</mn><msup><mn>0</mn><mn>9</mn></msup></mrow><annotation encoding=\\\"application/x-tex\\\">1...10^9</annotation></semantics></math></span><span class=\\\"katex-html\\\" aria-hidden=\\\"true\\\"><span class=\\\"base\\\"><span class=\\\"strut\\\" style=\\\"height:0.8141em;\\\"></span><span class=\\\"mord\\\">1...1</span><span class=\\\"mord\\\"><span class=\\\"mord\\\">0</span><span class=\\\"msupsub\\\"><span class=\\\"vlist-t\\\"><span class=\\\"vlist-r\\\"><span class=\\\"vlist\\\" style=\\\"height:0.8141em;\\\"><span style=\\\"top:-3.063em;margin-right:0.05em;\\\"><span class=\\\"pstrut\\\" style=\\\"height:2.7em;\\\"></span><span class=\\\"sizing reset-size6 size3 mtight\\\"><span class=\\\"mord mtight\\\">9</span></span></span></span></span></span></span></span></span></span></span>\"\n        }), \" is used in updates. In fact, there can be large intervals of indices that all have the same value. Call every index that is named in the input is a \\\"special index.\\\" Now, note that the value at each index in the interval between two consecutive special indices is the same. This is because it is impossible for there to be an update that cuts in between two consecutive special indices as that would imply the existence of another special index between two consecutive special indices, i.e. a contradiction. We'll call the interval between two consecutive special indices a \\\"special interval,\\\" and the \\\"value of a special interval\\\" will be the value that each of the elements take on inside it.\"]\n      }), _jsx(_components.p, {\n        children: \"Now, let's see how prefix sums (along with coordinate compression) helps.\"\n      }), _jsxs(_components.p, {\n        children: [\"Temporarily forget about special indices. When an update asks us to add \", _jsx(MATHSPAN, {\n          className: \"math math-inline\",\n          latex: \"+v\",\n          children: \"<span class=\\\"katex\\\"><span class=\\\"katex-mathml\\\"><math xmlns=\\\"http://www.w3.org/1998/Math/MathML\\\"><semantics><mrow><mo>+</mo><mi>v</mi></mrow><annotation encoding=\\\"application/x-tex\\\">+v</annotation></semantics></math></span><span class=\\\"katex-html\\\" aria-hidden=\\\"true\\\"><span class=\\\"base\\\"><span class=\\\"strut\\\" style=\\\"height:0.6667em;vertical-align:-0.0833em;\\\"></span><span class=\\\"mord\\\">+</span><span class=\\\"mord mathnormal\\\" style=\\\"margin-right:0.03588em;\\\">v</span></span></span></span>\"\n        }), \" to the interval \", _jsx(MATHSPAN, {\n          className: \"math math-inline\",\n          latex: \"[l, r)\",\n          children: \"<span class=\\\"katex\\\"><span class=\\\"katex-mathml\\\"><math xmlns=\\\"http://www.w3.org/1998/Math/MathML\\\"><semantics><mrow><mo stretchy=\\\"false\\\">[</mo><mi>l</mi><mo separator=\\\"true\\\">,</mo><mi>r</mi><mo stretchy=\\\"false\\\">)</mo></mrow><annotation encoding=\\\"application/x-tex\\\">[l, r)</annotation></semantics></math></span><span class=\\\"katex-html\\\" aria-hidden=\\\"true\\\"><span class=\\\"base\\\"><span class=\\\"strut\\\" style=\\\"height:1em;vertical-align:-0.25em;\\\"></span><span class=\\\"mopen\\\">[</span><span class=\\\"mord mathnormal\\\" style=\\\"margin-right:0.01968em;\\\">l</span><span class=\\\"mpunct\\\">,</span><span class=\\\"mspace\\\" style=\\\"margin-right:0.1667em;\\\"></span><span class=\\\"mord mathnormal\\\" style=\\\"margin-right:0.02778em;\\\">r</span><span class=\\\"mclose\\\">)</span></span></span></span>\"\n        }), \", we can mark index \", _jsx(MATHSPAN, {\n          className: \"math math-inline\",\n          latex: \"l\",\n          children: \"<span class=\\\"katex\\\"><span class=\\\"katex-mathml\\\"><math xmlns=\\\"http://www.w3.org/1998/Math/MathML\\\"><semantics><mrow><mi>l</mi></mrow><annotation encoding=\\\"application/x-tex\\\">l</annotation></semantics></math></span><span class=\\\"katex-html\\\" aria-hidden=\\\"true\\\"><span class=\\\"base\\\"><span class=\\\"strut\\\" style=\\\"height:0.6944em;\\\"></span><span class=\\\"mord mathnormal\\\" style=\\\"margin-right:0.01968em;\\\">l</span></span></span></span>\"\n        }), \" with \", _jsx(MATHSPAN, {\n          className: \"math math-inline\",\n          latex: \"+v\",\n          children: \"<span class=\\\"katex\\\"><span class=\\\"katex-mathml\\\"><math xmlns=\\\"http://www.w3.org/1998/Math/MathML\\\"><semantics><mrow><mo>+</mo><mi>v</mi></mrow><annotation encoding=\\\"application/x-tex\\\">+v</annotation></semantics></math></span><span class=\\\"katex-html\\\" aria-hidden=\\\"true\\\"><span class=\\\"base\\\"><span class=\\\"strut\\\" style=\\\"height:0.6667em;vertical-align:-0.0833em;\\\"></span><span class=\\\"mord\\\">+</span><span class=\\\"mord mathnormal\\\" style=\\\"margin-right:0.03588em;\\\">v</span></span></span></span>\"\n        }), \" and index \", _jsx(MATHSPAN, {\n          className: \"math math-inline\",\n          latex: \"r\",\n          children: \"<span class=\\\"katex\\\"><span class=\\\"katex-mathml\\\"><math xmlns=\\\"http://www.w3.org/1998/Math/MathML\\\"><semantics><mrow><mi>r</mi></mrow><annotation encoding=\\\"application/x-tex\\\">r</annotation></semantics></math></span><span class=\\\"katex-html\\\" aria-hidden=\\\"true\\\"><span class=\\\"base\\\"><span class=\\\"strut\\\" style=\\\"height:0.4306em;\\\"></span><span class=\\\"mord mathnormal\\\" style=\\\"margin-right:0.02778em;\\\">r</span></span></span></span>\"\n        }), \" with \", _jsx(MATHSPAN, {\n          className: \"math math-inline\",\n          latex: \"-v\",\n          children: \"<span class=\\\"katex\\\"><span class=\\\"katex-mathml\\\"><math xmlns=\\\"http://www.w3.org/1998/Math/MathML\\\"><semantics><mrow><mo>−</mo><mi>v</mi></mrow><annotation encoding=\\\"application/x-tex\\\">-v</annotation></semantics></math></span><span class=\\\"katex-html\\\" aria-hidden=\\\"true\\\"><span class=\\\"base\\\"><span class=\\\"strut\\\" style=\\\"height:0.6667em;vertical-align:-0.0833em;\\\"></span><span class=\\\"mord\\\">−</span><span class=\\\"mord mathnormal\\\" style=\\\"margin-right:0.03588em;\\\">v</span></span></span></span>\"\n        }), \" in a \\\"difference array.\\\" We call it the difference array because it tells us the change in value when we go from one index to the next. Taking the prefix sums of the difference array will result in the actual values of the array \", _jsx(MATHSPAN, {\n          className: \"math math-inline\",\n          latex: \"a\",\n          children: \"<span class=\\\"katex\\\"><span class=\\\"katex-mathml\\\"><math xmlns=\\\"http://www.w3.org/1998/Math/MathML\\\"><semantics><mrow><mi>a</mi></mrow><annotation encoding=\\\"application/x-tex\\\">a</annotation></semantics></math></span><span class=\\\"katex-html\\\" aria-hidden=\\\"true\\\"><span class=\\\"base\\\"><span class=\\\"strut\\\" style=\\\"height:0.4306em;\\\"></span><span class=\\\"mord mathnormal\\\">a</span></span></span></span>\"\n        }), \" (Take some time to convince yourself of this before moving on).\"]\n      }), _jsxs(_components.p, {\n        children: [\"Since the indices that we have to mark range from \", _jsx(MATHSPAN, {\n          className: \"math math-inline\",\n          latex: \"0...10^9\",\n          children: \"<span class=\\\"katex\\\"><span class=\\\"katex-mathml\\\"><math xmlns=\\\"http://www.w3.org/1998/Math/MathML\\\"><semantics><mrow><mn>0...1</mn><msup><mn>0</mn><mn>9</mn></msup></mrow><annotation encoding=\\\"application/x-tex\\\">0...10^9</annotation></semantics></math></span><span class=\\\"katex-html\\\" aria-hidden=\\\"true\\\"><span class=\\\"base\\\"><span class=\\\"strut\\\" style=\\\"height:0.8141em;\\\"></span><span class=\\\"mord\\\">0...1</span><span class=\\\"mord\\\"><span class=\\\"mord\\\">0</span><span class=\\\"msupsub\\\"><span class=\\\"vlist-t\\\"><span class=\\\"vlist-r\\\"><span class=\\\"vlist\\\" style=\\\"height:0.8141em;\\\"><span style=\\\"top:-3.063em;margin-right:0.05em;\\\"><span class=\\\"pstrut\\\" style=\\\"height:2.7em;\\\"></span><span class=\\\"sizing reset-size6 size3 mtight\\\"><span class=\\\"mord mtight\\\">9</span></span></span></span></span></span></span></span></span></span></span>\"\n        }), \", it'd take too much memory for us to use those indices directly. However, only special indices are ever actually used, so we're motivated to change the meaning of the difference array to save on memory (note that there are at most \", _jsx(MATHSPAN, {\n          className: \"math math-inline\",\n          latex: \"2 \\\\cdot (N+Q)\",\n          children: \"<span class=\\\"katex\\\"><span class=\\\"katex-mathml\\\"><math xmlns=\\\"http://www.w3.org/1998/Math/MathML\\\"><semantics><mrow><mn>2</mn><mo>⋅</mo><mo stretchy=\\\"false\\\">(</mo><mi>N</mi><mo>+</mo><mi>Q</mi><mo stretchy=\\\"false\\\">)</mo></mrow><annotation encoding=\\\"application/x-tex\\\">2 \\\\cdot (N+Q)</annotation></semantics></math></span><span class=\\\"katex-html\\\" aria-hidden=\\\"true\\\"><span class=\\\"base\\\"><span class=\\\"strut\\\" style=\\\"height:0.6444em;\\\"></span><span class=\\\"mord\\\">2</span><span class=\\\"mspace\\\" style=\\\"margin-right:0.2222em;\\\"></span><span class=\\\"mbin\\\">⋅</span><span class=\\\"mspace\\\" style=\\\"margin-right:0.2222em;\\\"></span></span><span class=\\\"base\\\"><span class=\\\"strut\\\" style=\\\"height:1em;vertical-align:-0.25em;\\\"></span><span class=\\\"mopen\\\">(</span><span class=\\\"mord mathnormal\\\" style=\\\"margin-right:0.10903em;\\\">N</span><span class=\\\"mspace\\\" style=\\\"margin-right:0.2222em;\\\"></span><span class=\\\"mbin\\\">+</span><span class=\\\"mspace\\\" style=\\\"margin-right:0.2222em;\\\"></span></span><span class=\\\"base\\\"><span class=\\\"strut\\\" style=\\\"height:1em;vertical-align:-0.25em;\\\"></span><span class=\\\"mord mathnormal\\\">Q</span><span class=\\\"mclose\\\">)</span></span></span></span>\"\n        }), \" special indices because \", _jsx(MATHSPAN, {\n          className: \"math math-inline\",\n          latex: \"2\",\n          children: \"<span class=\\\"katex\\\"><span class=\\\"katex-mathml\\\"><math xmlns=\\\"http://www.w3.org/1998/Math/MathML\\\"><semantics><mrow><mn>2</mn></mrow><annotation encoding=\\\"application/x-tex\\\">2</annotation></semantics></math></span><span class=\\\"katex-html\\\" aria-hidden=\\\"true\\\"><span class=\\\"base\\\"><span class=\\\"strut\\\" style=\\\"height:0.6444em;\\\"></span><span class=\\\"mord\\\">2</span></span></span></span>\"\n        }), \" indices are given for every update and query). Instead of the difference array representing the change in value from one special index to the next, let it represent the change in value from one special interval to the next. Now, it only has to have size \", _jsx(MATHSPAN, {\n          className: \"math math-inline\",\n          latex: \"2 \\\\cdot (N+Q)\",\n          children: \"<span class=\\\"katex\\\"><span class=\\\"katex-mathml\\\"><math xmlns=\\\"http://www.w3.org/1998/Math/MathML\\\"><semantics><mrow><mn>2</mn><mo>⋅</mo><mo stretchy=\\\"false\\\">(</mo><mi>N</mi><mo>+</mo><mi>Q</mi><mo stretchy=\\\"false\\\">)</mo></mrow><annotation encoding=\\\"application/x-tex\\\">2 \\\\cdot (N+Q)</annotation></semantics></math></span><span class=\\\"katex-html\\\" aria-hidden=\\\"true\\\"><span class=\\\"base\\\"><span class=\\\"strut\\\" style=\\\"height:0.6444em;\\\"></span><span class=\\\"mord\\\">2</span><span class=\\\"mspace\\\" style=\\\"margin-right:0.2222em;\\\"></span><span class=\\\"mbin\\\">⋅</span><span class=\\\"mspace\\\" style=\\\"margin-right:0.2222em;\\\"></span></span><span class=\\\"base\\\"><span class=\\\"strut\\\" style=\\\"height:1em;vertical-align:-0.25em;\\\"></span><span class=\\\"mopen\\\">(</span><span class=\\\"mord mathnormal\\\" style=\\\"margin-right:0.10903em;\\\">N</span><span class=\\\"mspace\\\" style=\\\"margin-right:0.2222em;\\\"></span><span class=\\\"mbin\\\">+</span><span class=\\\"mspace\\\" style=\\\"margin-right:0.2222em;\\\"></span></span><span class=\\\"base\\\"><span class=\\\"strut\\\" style=\\\"height:1em;vertical-align:-0.25em;\\\"></span><span class=\\\"mord mathnormal\\\">Q</span><span class=\\\"mclose\\\">)</span></span></span></span>\"\n        }), \". Taking the prefix sums of this difference array will give the values of all special intervals.\"]\n      }), _jsxs(_components.p, {\n        children: [\"We just have to coordinate compress the special indices so that we can conveniently use them as array indices for the difference array. We perform this coordinate compression by keeping a sorted list of all special indices, and using each special index's position in that list as its compressed index. To find a special index's position in the sorted list (a.k.a. its compressed index), we can \", _jsx(_components.a, {\n          href: \"/silver/binary-search\",\n          children: \"binary search\"\n        }), \" on the list. The next part of the solution will show why it was important for us to store the original indices.\"]\n      }), _jsx(_components.p, {\n        children: \"So, with prefix sums and coordinate compression, it is possible for us to find the value of each special interval. Now, let's finish the problem. Let the \\\"sum of a special interval\\\" be the sum of every element inside the special interval, or in other words, the interval's length times its value. We already know each special interval's value, but we can also get its length because we stored the original indices. The length of an interval is its right index minus its left index, which we can find by accessing the sorted list. As a result, we can also find the sum of each special interval with the information we have. When the problem queries us for the sum between two special indices, we add up the sums of the special intervals between those two special indices. Thus, if we create another prefix sum array on the sums of the special intervals, we can easily answer these range sum queries in O(1) each.\"\n      }), _jsx(_components.p, {\n        children: \"The code below can be expanded to show the full solution.\"\n      })]\n    }), \"\\n\", _jsxs(LanguageSection, {\n      children: [_jsx(CPPSection, {\n        children: _jsx(_components.pre, {\n          children: _jsx(_components.code, {\n            className: \"language-cpp\",\n            children: \"//BeginCodeSnip{Solution code}\\n#include <bits/stdc++.h>\\n\\nusing namespace std;\\n\\ntypedef long long ll;\\n\\nll difference_array[400005]; \\n//difference_array[i] = the difference of the values between special intervals i-1 and i\\n\\nint widths[400005]; //width[i] = the length of special interval i\\nll interval_value[400005]; //interval_value[i] = the value of special interval i\\n//the sum of a special interval is interval_value[i] * width[i]\\n\\nll prefix_sums[400005]; //prefix_sums[i] = prefix sum of the sums of special intervals up to i\\n\\nvector<int> indices; //sorted list of special indices\\npair<int, int> queries[100005]; //queries given in the input <l, r>\\npair<pair<int, int>, int> updates[100005]; //updates in given in the input <<l, r>, v>\\n\\n//EndCodeSnip\\n\\n//finds the \\\"compressed index\\\" of a special index (a.k.a. its position in the sorted list)\\nint getCompressedIndex(int a) {\\n\\treturn lower_bound(indices.begin(), indices.end(), a) - indices.begin();\\n}\\n\\n//BeginCodeSnip{Solution code}\\n\\nint main() {\\n\\tios_base::sync_with_stdio(false);\\n\\tcin.tie(NULL);\\n\\n\\tint N, Q;\\n\\tcin >> N >> Q;\\n\\n\\tfor(int i = 0; i < N; i++) {\\n\\t\\tint l, r, v;\\n\\t\\tcin >> l >> r >> v;\\n\\t\\tindices.push_back(l);\\n\\t\\tindices.push_back(r);\\n\\t\\tupdates[i] = {{l, r}, v};\\n\\t}\\n\\tfor(int i = 0; i < Q; i++) {\\n\\t\\tint l, r;\\n\\t\\tcin >> l >> r;\\n\\t\\tindices.push_back(l);\\n\\t\\tindices.push_back(r);\\n\\t\\tqueries[i] = {l, r};\\n\\t}\\n//EndCodeSnip\\n\\t//========= COORDINATE COMPRESSION =======\\n\\tsort(indices.begin(), indices.end());\\n\\tindices.erase(unique(indices.begin(), indices.end()), indices.end());\\n\\t\\t/*\\n\\t\\tYou can find info on \\\"unique\\\" here: https://www.cplusplus.com/reference/algorithm/unique/\\n\\n\\t\\tSince our list is already sorted, the effect of \\\"unique\\\" is duplicates are removed. In total, these two lines\\n\\t\\tgive us a sorted list with duplicates removed.\\n\\t\\t*/\\n\\t//========= COORDINATE COMPRESSION =======\\n//BeginCodeSnip{Solution code}\\n\\t//We create the difference array, using coordinate compression and binary search to get the compressed index of each special index\\n\\t//Note the 1-based indexing for convenience\\n\\tfor(int i = 0; i < N; i++) {\\n\\t\\tauto a = updates[i];\\n\\n\\t\\tdifference_array[getCompressedIndex(a.first.first)+1] += a.second;\\n\\t\\tdifference_array[getCompressedIndex(a.first.second)+1] -= a.second;\\n\\t}\\n\\n\\t//By keeping track of the original values of the special indices, we can also figure out the lengths of each special interval\\n\\tfor(int i = 0; i < indices.size()-1; i++) {\\n\\t\\twidths[i+1] = indices[i+1] - indices[i];\\n\\t}\\n\\n\\t//We use prefix sums of the difference array to get the values of the intervals\\n\\tfor(int i = 1; i < indices.size(); i++) {\\n\\t\\tinterval_value[i] = interval_value[i-1] + difference_array[i];\\n\\t}\\n\\n\\t//We use prefix sums over the sums of the special intervals to be able to answer queries quickly\\n\\tfor(int i = 1; i < indices.size(); i++) {\\n\\t\\tprefix_sums[i] = prefix_sums[i-1] + interval_value[i] * widths[i];\\n\\t}\\n\\n\\t//Classic use of prefix sum array to answer range sum queries\\n\\tfor(int i = 0; i < Q; i++) {\\n\\t\\tcout << prefix_sums[getCompressedIndex(queries[i].second)] - prefix_sums[getCompressedIndex(queries[i].first)] << \\\"\\\\n\\\";\\n\\t}\\n\\n\\treturn 0;\\n}\\n//EndCodeSnip\\n\"\n          })\n        })\n      }), _jsx(JavaSection, {\n        children: _jsx(_components.pre, {\n          children: _jsx(_components.code, {\n            className: \"language-java\",\n            children: \"//BeginCodeSnip{Solution code}\\nimport java.util.*;\\nimport java.io.*;\\n\\npublic class rangequeries {\\n\\t\\n\\t//custom class that stores a few integers (used for directly storing the queries and updates given in the input)\\n\\tstatic class Query {\\n\\t\\t\\n\\t\\tint l, r, v;\\n\\t\\tpublic Query(int l, int r, int v) {\\n\\t\\t\\tthis.l = l;\\n\\t\\t\\tthis.r = r;\\n\\t\\t\\tthis.v = v;\\n\\t\\t}\\n\\t\\t\\n\\t\\tpublic Query(int l, int r) {\\n\\t\\t\\tthis.l = l;\\n\\t\\t\\tthis.r = r;\\n\\t\\t}\\n\\t\\t\\n\\t}\\n\\t\\n\\tstatic long difference_array[]; \\n\\t//difference_array[i] = the difference of the values between special intervals i-1 and i\\n\\n\\tstatic int widths[]; //width[i] = the length of special interval i\\n\\tstatic long interval_value[]; //interval_value[i] = the value of special interval i\\n\\n\\tstatic long prefix_sums[]; //prefix_sums[i] = prefix sum of the sums of special intervals up to i\\n\\n\\tstatic ArrayList<Integer> indices; //sorted list of special indices\\n\\tstatic Query queries[]; //queries given in the input <l, r>\\n\\tstatic Query updates[]; //updates in given in the input <l, r, v>\\n//EndCodeSnip\\n\\t//finds the \\\"compressed index\\\" of a special index (a.k.a. its position in the sorted list)\\n\\tstatic int getCompressedIndex(int a) {\\n\\t\\treturn Collections.binarySearch(indices, a);\\n\\t}\\n//BeginCodeSnip{Solution code}\\n\\tpublic static void main(String[] args) throws Exception {\\n\\t\\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in)); // A Scanner is too slow to solve this problem!\\n\\t\\t\\n\\t\\tStringTokenizer st = new StringTokenizer(br.readLine());\\n\\t\\tint N = Integer.parseInt(st.nextToken()), Q = Integer.parseInt(st.nextToken());\\n\\t\\t\\n\\t\\tindices = new ArrayList<Integer>();\\n\\t\\tqueries = new Query[Q];\\n\\t\\tupdates = new Query[N];\\n\\t\\t\\n\\t\\tfor(int i = 0; i < N; i++) {\\n\\t\\t\\tst = new StringTokenizer(br.readLine());\\n\\t\\t\\tint l = Integer.parseInt(st.nextToken()), r = Integer.parseInt(st.nextToken()), v = Integer.parseInt(st.nextToken());\\n\\t\\t\\tindices.add(l);\\n\\t\\t\\tindices.add(r);\\n\\t\\t\\tupdates[i] = new Query(l, r, v);\\n\\t\\t}\\n\\t\\tfor(int i = 0; i < Q; i++) {\\n\\t\\t\\tst = new StringTokenizer(br.readLine());\\n\\t\\t\\tint l = Integer.parseInt(st.nextToken()), r = Integer.parseInt(st.nextToken());\\n\\t\\t\\tindices.add(l);\\n\\t\\t\\tindices.add(r);\\n\\t\\t\\tqueries[i] = new Query(l, r);\\n\\t\\t}\\n//EndCodeSnip\\n\\t\\t//========= COORDINATE COMPRESSION =======\\n\\t\\tTreeSet<Integer> temp = new TreeSet<Integer>(indices); \\n\\t\\t//Since temp is a set, all duplicate elements are removed\\n\\t\\tindices.clear(); \\n\\t\\tindices.addAll(temp); //The elements of temp will be added to indices in sorted order, since temp is a TreeSet\\n\\t\\t//The effect of these lines is to sort indices while removing duplicate elements. \\n\\t\\t//While this is not the only way to do it, it is one that requires little code.\\n\\t\\t//========= COORDINATE COMPRESSION =======\\n//BeginCodeSnip{Solution code}\\n\\t\\tdifference_array = new long[indices.size() + 5];\\n\\t\\twidths = new int[indices.size() + 5];\\n\\t\\tinterval_value = new long[indices.size() + 5];\\n\\t\\tprefix_sums = new long[indices.size() + 5];\\n\\t\\t\\n\\t\\t//We create the difference array, using coordinate compression and binary search to get the index of each special interval\\n\\t\\t//Note the 1-based indexing for convenience\\n\\t\\tfor(int i = 0; i < N; i++) {\\n\\t\\t\\tQuery a = updates[i];\\n\\n\\t\\t\\tdifference_array[getCompressedIndex(a.l)+1] += a.v;\\n\\t\\t\\tdifference_array[getCompressedIndex(a.r)+1] -= a.v;\\n\\t\\t}\\n\\n\\t\\t//By keeping track of the original values of the special indices, we can also figure out the lengths of each special interval\\n\\t\\tfor(int i = 0; i < indices.size()-1; i++) {\\n\\t\\t\\twidths[i+1] = indices.get(i+1) - indices.get(i);\\n\\t\\t}\\n\\n\\t\\t//We use prefix sums of the difference array to get the actual value of the intervals\\n\\t\\tfor(int i = 1; i < indices.size(); i++) {\\n\\t\\t\\tinterval_value[i] = interval_value[i-1] + difference_array[i];\\n\\t\\t}\\n\\n\\t\\t//We use prefix sums over the sums of the special intervals to be able to answer queries quickly\\n\\t\\tfor(int i = 1; i < indices.size(); i++) {\\n\\t\\t\\tprefix_sums[i] = prefix_sums[i-1] + interval_value[i] * widths[i];\\n\\t\\t}\\n\\n\\t\\t//Classic use of prefix sum array to answer range sum queries\\n\\t\\tfor(int i = 0; i < Q; i++) {\\n\\t\\t\\tSystem.out.println(prefix_sums[getCompressedIndex(queries[i].r)] - prefix_sums[getCompressedIndex(queries[i].l)]);\\n\\t\\t}\\n\\t\\t\\n\\t}\\n\\t\\n}\\n//EndCodeSnip\\n\"\n          })\n        })\n      })]\n    }), \"\\n\", _jsxs(_components.h2, {\n      id: \"problems\",\n      children: [_jsx(_components.a, {\n        href: \"#problems\",\n        \"aria-hidden\": \"true\",\n        tabIndex: \"-1\",\n        className: \"anchor before\",\n        children: _jsx(HeaderLink, {})\n      }), \"Problems\"]\n    }), \"\\n\", _jsx(Info, {\n      title: \"Pro Tip\",\n      children: _jsxs(_components.p, {\n        children: [\"Many of the problems below may use other Silver concepts, such as\\n\", _jsx(_components.a, {\n          href: \"/silver/prefix-sums\",\n          children: \"prefix sums\"\n        }), \".\"]\n      })\n    }), \"\\n\", _jsx(Problems, {\n      problems: \"general\",\n      hideSuggestProblemButton: true\n    })]\n  });\n  return MDXLayout ? _jsx(MDXLayout, Object.assign({}, _props, {\n    children: _content\n  })) : _content;\n}\nreturn {\n  id,\n  title,\n  frequency,\n  author,\n  prerequisites,\n  description,\n  default: MDXContent\n};\n","frontmatter":{"title":"Custom Comparators and Coordinate Compression","author":"Darren Yao, Siyong Huang, Michael Cao, Benjamin Qi, Nathan Chen","contributors":null,"id":"sorting-custom","prerequisites":["intro-sorting","intro-graphs"],"description":"Using a custom comparator to sort custom objects or values in a non-default order; Coordinate compressing values from a large range to a smaller one.","frequency":3},"parent":{"name":"Sorting_Custom","relativePath":"3_Silver/Sorting_Custom.mdx"},"fields":{"division":"silver"},"toc":{"cpp":[{"depth":2,"value":"Example - Wormhole Sort","slug":"example---wormhole-sort"},{"depth":2,"value":"Classes","slug":"classes"},{"depth":3,"value":"C++","slug":"c"},{"depth":2,"value":"Comparators","slug":"comparators"},{"depth":3,"value":"Method 1 - Overloading the Less Than Operator","slug":"method-1---overloading-the-less-than-operator"},{"depth":3,"value":"Method 2 - Comparison Function","slug":"method-2---comparison-function"},{"depth":2,"value":"Variations","slug":"variations"},{"depth":3,"value":"Sorting in Decreasing Order of Weight","slug":"sorting-in-decreasing-order-of-weight"},{"depth":3,"value":"Sorting by Two Criteria","slug":"sorting-by-two-criteria"},{"depth":2,"value":"Coordinate Compression","slug":"coordinate-compression"},{"depth":3,"value":"Example 1","slug":"example-1"},{"depth":3,"value":"Example 2","slug":"example-2"},{"depth":2,"value":"Problems","slug":"problems"}],"java":[{"depth":2,"value":"Example - Wormhole Sort","slug":"example---wormhole-sort"},{"depth":2,"value":"Classes","slug":"classes"},{"depth":2,"value":"Comparators","slug":"comparators"},{"depth":3,"value":"Method 1 - Comparable","slug":"method-1---comparable"},{"depth":3,"value":"Method 2 - Comparator","slug":"method-2---comparator"},{"depth":2,"value":"Variations","slug":"variations"},{"depth":3,"value":"Sorting in Decreasing Order of Weight","slug":"sorting-in-decreasing-order-of-weight"},{"depth":3,"value":"Sorting by Two Criteria","slug":"sorting-by-two-criteria"},{"depth":2,"value":"Coordinate Compression","slug":"coordinate-compression"},{"depth":3,"value":"Example 1","slug":"example-1"},{"depth":3,"value":"Example 2","slug":"example-2"},{"depth":2,"value":"Problems","slug":"problems"}],"py":[{"depth":2,"value":"Example - Wormhole Sort","slug":"example---wormhole-sort"},{"depth":2,"value":"Classes","slug":"classes"},{"depth":2,"value":"Comparators","slug":"comparators"},{"depth":3,"value":"Defining Less Than Operator","slug":"defining-less-than-operator"},{"depth":3,"value":"Key Function","slug":"key-function"},{"depth":3,"value":"Comparison Function","slug":"comparison-function"},{"depth":2,"value":"Variations","slug":"variations"},{"depth":3,"value":"Sorting in Decreasing Order of Weight","slug":"sorting-in-decreasing-order-of-weight"},{"depth":3,"value":"Sorting by Two Criteria","slug":"sorting-by-two-criteria"},{"depth":2,"value":"Coordinate Compression","slug":"coordinate-compression"},{"depth":3,"value":"Example 1","slug":"example-1"},{"depth":3,"value":"Example 2","slug":"example-2"},{"depth":2,"value":"Problems","slug":"problems"}]}},"moduleProblemLists":{"problemLists":[{"listId":"sample","problems":[{"uniqueId":"usaco-992","name":"Wormhole Sort","url":"http://www.usaco.org/index.php?page=viewproblem2&cpid=992","source":"Silver","difficulty":"Insane","isStarred":false,"tags":[],"solution":{"kind":"internal","label":null,"labelTooltip":null,"url":null,"sketch":null}}]},{"listId":"sample2","problems":[{"uniqueId":"usaco-1063","name":"Rectangular Pasture","url":"http://www.usaco.org/index.php?page=viewproblem2&cpid=1063","source":"Silver","difficulty":"Hard","isStarred":false,"tags":["2D Prefix Sums"],"solution":{"kind":"link","label":"External Sol","labelTooltip":null,"url":"http://www.usaco.org/current/data/sol_prob2_silver_dec20.html","sketch":null}}]},{"listId":"sample3","problems":[{"uniqueId":"cfgym-102951D","name":"Static Range Queries","url":"https://codeforces.com/gym/102951/problem/D","source":"CF","difficulty":"Hard","isStarred":false,"tags":[],"solution":{"kind":"link","label":"In Module","labelTooltip":null,"url":"https://usaco.guide/silver/sorting-custom#problem-cfgym-102951D","sketch":null}}]},{"listId":"general","problems":[{"uniqueId":"cses-1619","name":"Restaurant Customers","url":"https://cses.fi/problemset/task/1619","source":"CSES","difficulty":"Easy","isStarred":false,"tags":["Sorting","Prefix Sums"],"solution":{"kind":"internal","label":null,"labelTooltip":null,"url":null,"sketch":null}},{"uniqueId":"usaco-786","name":"Lifeguards","url":"http://www.usaco.org/index.php?page=viewproblem2&cpid=786","source":"Silver","difficulty":"Easy","isStarred":false,"tags":["Sorting","Prefix Sums"],"solution":{"kind":"internal","label":null,"labelTooltip":null,"url":null,"sketch":null}},{"uniqueId":"usaco-787","name":"Rental Service","url":"http://www.usaco.org/index.php?page=viewproblem2&cpid=787","source":"Silver","difficulty":"Normal","isStarred":true,"tags":["Sorting","Prefix Sums"],"solution":{"kind":"internal","label":null,"labelTooltip":null,"url":null,"sketch":null}},{"uniqueId":"usaco-896","name":"Mountain View","url":"http://www.usaco.org/index.php?page=viewproblem2&cpid=896","source":"Silver","difficulty":"Normal","isStarred":true,"tags":["Sorting"],"solution":{"kind":"internal","label":null,"labelTooltip":null,"url":null,"sketch":null}},{"uniqueId":"usaco-1064","name":"Stuck in a Rut","url":"http://www.usaco.org/index.php?page=viewproblem2&cpid=1064","source":"Silver","difficulty":"Normal","isStarred":false,"tags":["Sorting"],"solution":{"kind":"internal","label":null,"labelTooltip":null,"url":null,"sketch":null}},{"uniqueId":"usaco-645","name":"Splitting the Field","url":"http://www.usaco.org/index.php?page=viewproblem2&cpid=645","source":"Gold","difficulty":"Normal","isStarred":true,"tags":["Sorting","Prefix Sums"],"solution":{"kind":"internal","label":null,"labelTooltip":null,"url":null,"sketch":null}},{"uniqueId":"cf-632C","name":"The Smallest String Concatenation","url":"https://codeforces.com/problemset/problem/632/C","source":"CF","difficulty":"Normal","isStarred":false,"tags":["Sorting"],"solution":{"kind":"label","label":"Check CF","labelTooltip":"Check contest materials, located to the right of the problem statement.","url":null,"sketch":null}},{"uniqueId":"cf-1478C","name":"Nezzar and Symmetric Array","url":"https://codeforces.com/problemset/problem/1478/C","source":"CF","difficulty":"Normal","isStarred":false,"tags":["Sorting","Prefix Sums"],"solution":{"kind":"label","label":"Check CF","labelTooltip":"Check contest materials, located to the right of the problem statement.","url":null,"sketch":null}},{"uniqueId":"cf-1472E","name":"Correct Placement","url":"https://codeforces.com/problemset/problem/1472/E","source":"CF","difficulty":"Normal","isStarred":false,"tags":["Sorting"],"solution":{"kind":"label","label":"Check CF","labelTooltip":"Check contest materials, located to the right of the problem statement.","url":null,"sketch":null}},{"uniqueId":"usaco-1015","name":"Triangles","url":"http://www.usaco.org/index.php?page=viewproblem2&cpid=1015","source":"Silver","difficulty":"Hard","isStarred":false,"tags":["Sorting"],"solution":{"kind":"internal","label":null,"labelTooltip":null,"url":null,"sketch":null}},{"uniqueId":"usaco-834","name":"Out Of Sorts","url":"http://www.usaco.org/index.php?page=viewproblem2&cpid=834","source":"Silver","difficulty":"Hard","isStarred":false,"tags":["Sorting"],"solution":{"kind":"internal","label":null,"labelTooltip":null,"url":null,"sketch":null}},{"uniqueId":"usaco-967","name":"Meetings","url":"http://www.usaco.org/index.php?page=viewproblem2&cpid=967","source":"Silver","difficulty":"Very Hard","isStarred":false,"tags":["Sorting"],"solution":{"kind":"link","label":"External Sol","labelTooltip":null,"url":"http://www.usaco.org/current/data/sol_meetings_silver_dec19.html","sketch":null}}]}]}},"pageContext":{"id":"sorting-custom"}},
    "staticQueryHashes": ["3245546052","3813215756","745520438"]}