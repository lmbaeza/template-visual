{
    "componentChunkName": "component---src-templates-module-template-tsx",
    "path": "/silver/intro-tree",
    "result": {"data":{"xdm":{"body":"/*@jsxRuntime automatic @jsxImportSource react*/\n/*\n<Spoiler title=\"Some common terms relating to trees\">\n*/\n/*</Spoiler>*/\n/*Typically, after arbitrarily rooting a tree, some interesting pieces of information are a node's parent, subtree size, and depth.*/\n/*\n## Computing parent, depth, and subtree sizes\n\nThe following sample code computes the **parent**, **depth**, and **subtree sizes** of each node of a tree, assuming node 1 is the root.\n\n<LanguageSection>\n\n<CPPSection>\n\n```cpp\n//Not Tested\n#include <cstdio>\n#include <vector>\n\nconst int MN = 2e5+10;\nstd::vector<int> a[MN];\nint p[MN], d[MN], s[MN];\nvoid dfs(int n)\n{\ns[n]=1;\nfor(int x:a[n])\nif(x!=p[n])\n{\nd[x]=d[n]+1;\np[x]=n;\ndfs(x);\ns[n]+=s[x];\n}\n}\nint main()\n{\nfor(int i=0,x,y;i+1<N;++i)\nscanf(\"%d%d\", &x, &y), a[x].push_back(y), a[y].push_back(x);\np[0]=-1;\nd[0]=0;\ndfs(1);\n//do something\n}\n```\n\n</CPPSection>\n\n</LanguageSection>\n\n*/\n/*<Info>\n\nFor the last two problems, try solving them on a tree first.\n\n</Info>*/\nconst {Fragment: _Fragment, jsx: _jsx, jsxs: _jsxs} = arguments[0];\nfunction _missingComponent(name) {\n  return function () {\n    throw new Error(\"Component `\" + name + \"` was not imported, exported, or given\");\n  };\n}\nconst id = \"intro-tree\", title = \"Introduction to Tree Algorithms\", author = \"Nathan Chen, Siyong Huang, Albert Ye\", prerequisites = [\"dfs\"], description = \"Introducing a special type of graph: trees.\", frequency = 1;\nfunction MDXContent(_props) {\n  const _components = Object.assign({\n    p: \"p\",\n    strong: \"strong\",\n    h2: \"h2\",\n    a: \"a\",\n    ul: \"ul\",\n    li: \"li\",\n    em: \"em\",\n    pre: \"pre\",\n    code: \"code\",\n    FocusProblem: _missingComponent(\"FocusProblem\"),\n    HeaderLink: _missingComponent(\"HeaderLink\"),\n    Resources: _missingComponent(\"Resources\"),\n    Resource: _missingComponent(\"Resource\"),\n    MATHSPAN: _missingComponent(\"MATHSPAN\"),\n    LanguageSection: _missingComponent(\"LanguageSection\"),\n    CPPSection: _missingComponent(\"CPPSection\"),\n    JavaSection: _missingComponent(\"JavaSection\"),\n    Warning: _missingComponent(\"Warning\"),\n    PySection: _missingComponent(\"PySection\"),\n    Quiz: _missingComponent(\"Quiz\"),\n    Problems: _missingComponent(\"Problems\")\n  }, _props.components), {FocusProblem, HeaderLink, Resources, Resource, MATHSPAN, LanguageSection, CPPSection, JavaSection, Warning, PySection, Quiz, Problems, wrapper: MDXLayout} = _components;\n  const _content = _jsxs(_Fragment, {\n    children: [_jsx(FocusProblem, {\n      problem: \"treeSam\"\n    }), \"\\n\", _jsx(\"br\", {}), \"\\n\", _jsxs(_components.p, {\n      children: [_jsx(_components.strong, {\n        children: \"Trees\"\n      }), \" are generally treated very differently from general graph problems.\"]\n    }), \"\\n\", _jsxs(_components.h2, {\n      id: \"resources\",\n      children: [_jsx(_components.a, {\n        href: \"#resources\",\n        \"aria-hidden\": \"true\",\n        tabIndex: \"-1\",\n        className: \"anchor before\",\n        children: _jsx(HeaderLink, {})\n      }), \"Resources\"]\n    }), \"\\n\", _jsxs(Resources, {\n      children: [_jsx(Resource, {\n        source: \"CPH\",\n        title: \"14.1, 14.2 - Tree algorithms\",\n        starred: true,\n        children: _jsx(_components.p, {\n          children: \"traversing tree, diameter\"\n        })\n      }), _jsx(Resource, {\n        source: \"SecondThread\",\n        title: \"Tree Basics - Tree Diameter\",\n        url: \"https://codeforces.com/blog/entry/81527\"\n      })]\n    }), \"\\n\", \"\\n\", _jsx(_components.p, {\n      children: \"Some properties/definitions of trees:\"\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsxs(_components.li, {\n        children: [\"A graph is a \", _jsx(_components.strong, {\n          children: \"tree\"\n        }), \" iff it is connected and contains \", _jsx(MATHSPAN, {\n          className: \"math math-inline\",\n          latex: \"N\",\n          children: \"<span class=\\\"katex\\\"><span class=\\\"katex-mathml\\\"><math xmlns=\\\"http://www.w3.org/1998/Math/MathML\\\"><semantics><mrow><mi>N</mi></mrow><annotation encoding=\\\"application/x-tex\\\">N</annotation></semantics></math></span><span class=\\\"katex-html\\\" aria-hidden=\\\"true\\\"><span class=\\\"base\\\"><span class=\\\"strut\\\" style=\\\"height:0.6833em;\\\"></span><span class=\\\"mord mathnormal\\\" style=\\\"margin-right:0.10903em;\\\">N</span></span></span></span>\"\n        }), \" nodes and \", _jsx(MATHSPAN, {\n          className: \"math math-inline\",\n          latex: \"N-1\",\n          children: \"<span class=\\\"katex\\\"><span class=\\\"katex-mathml\\\"><math xmlns=\\\"http://www.w3.org/1998/Math/MathML\\\"><semantics><mrow><mi>N</mi><mo>−</mo><mn>1</mn></mrow><annotation encoding=\\\"application/x-tex\\\">N-1</annotation></semantics></math></span><span class=\\\"katex-html\\\" aria-hidden=\\\"true\\\"><span class=\\\"base\\\"><span class=\\\"strut\\\" style=\\\"height:0.7667em;vertical-align:-0.0833em;\\\"></span><span class=\\\"mord mathnormal\\\" style=\\\"margin-right:0.10903em;\\\">N</span><span class=\\\"mspace\\\" style=\\\"margin-right:0.2222em;\\\"></span><span class=\\\"mbin\\\">−</span><span class=\\\"mspace\\\" style=\\\"margin-right:0.2222em;\\\"></span></span><span class=\\\"base\\\"><span class=\\\"strut\\\" style=\\\"height:0.6444em;\\\"></span><span class=\\\"mord\\\">1</span></span></span></span>\"\n        }), \"\\nedges\"]\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [\"A graph is a \", _jsx(_components.strong, {\n          children: \"tree\"\n        }), \" iff every pair of nodes has exactly one simple path\\nbetween them\"]\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [\"A graph is a \", _jsx(_components.strong, {\n          children: \"tree\"\n        }), \" iff it is connected and does not contain any cycles\"]\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"General Tree Terminology:\"\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsxs(_components.li, {\n        children: [\"A \", _jsx(_components.strong, {\n          children: \"leaf\"\n        }), \" of a tree is any node in the tree with degree \", _jsx(MATHSPAN, {\n          className: \"math math-inline\",\n          latex: \"1\",\n          children: \"<span class=\\\"katex\\\"><span class=\\\"katex-mathml\\\"><math xmlns=\\\"http://www.w3.org/1998/Math/MathML\\\"><semantics><mrow><mn>1</mn></mrow><annotation encoding=\\\"application/x-tex\\\">1</annotation></semantics></math></span><span class=\\\"katex-html\\\" aria-hidden=\\\"true\\\"><span class=\\\"base\\\"><span class=\\\"strut\\\" style=\\\"height:0.6444em;\\\"></span><span class=\\\"mord\\\">1</span></span></span></span>\"\n        }), \"\\n\", _jsxs(_components.ul, {\n          children: [\"\\n\", _jsxs(_components.li, {\n            children: [\"If the tree is rooted, the \", _jsx(_components.strong, {\n              children: \"root\"\n            }), \" with a single child is \", _jsx(_components.em, {\n              children: \"not\"\n            }), \" typically\\nconsidered a leaf, but depending on the problem, this is not always the case\"]\n          }), \"\\n\"]\n        }), \"\\n\"]\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [\"A \", _jsx(_components.strong, {\n          children: \"star graph\"\n        }), \" has two common definitions. Try to understand what they\\nmean - they typically appear in subtasks.\\n\", _jsxs(_components.ul, {\n          children: [\"\\n\", _jsxs(_components.li, {\n            children: [\"Definition 1: Only one node has degree greater than \", _jsx(MATHSPAN, {\n              className: \"math math-inline\",\n              latex: \"1\",\n              children: \"<span class=\\\"katex\\\"><span class=\\\"katex-mathml\\\"><math xmlns=\\\"http://www.w3.org/1998/Math/MathML\\\"><semantics><mrow><mn>1</mn></mrow><annotation encoding=\\\"application/x-tex\\\">1</annotation></semantics></math></span><span class=\\\"katex-html\\\" aria-hidden=\\\"true\\\"><span class=\\\"base\\\"><span class=\\\"strut\\\" style=\\\"height:0.6444em;\\\"></span><span class=\\\"mord\\\">1</span></span></span></span>\"\n            })]\n          }), \"\\n\", _jsxs(_components.li, {\n            children: [\"Definition 2: Only one node has degree greater than \", _jsx(MATHSPAN, {\n              className: \"math math-inline\",\n              latex: \"2\",\n              children: \"<span class=\\\"katex\\\"><span class=\\\"katex-mathml\\\"><math xmlns=\\\"http://www.w3.org/1998/Math/MathML\\\"><semantics><mrow><mn>2</mn></mrow><annotation encoding=\\\"application/x-tex\\\">2</annotation></semantics></math></span><span class=\\\"katex-html\\\" aria-hidden=\\\"true\\\"><span class=\\\"base\\\"><span class=\\\"strut\\\" style=\\\"height:0.6444em;\\\"></span><span class=\\\"mord\\\">2</span></span></span></span>\"\n            })]\n          }), \"\\n\"]\n        }), \"\\n\"]\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [\"A \", _jsx(_components.strong, {\n          children: \"forest\"\n        }), \" is a graph such that each \", _jsx(_components.strong, {\n          children: \"connected component\"\n        }), \" is a tree\"]\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Rooted Tree Terminology:\"\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsxs(_components.li, {\n        children: [\"A \", _jsx(_components.strong, {\n          children: \"root\"\n        }), \" of a tree is any node of the tree that is considered to be at the\\n'top'\"]\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [\"A \", _jsx(_components.strong, {\n          children: \"parent\"\n        }), \" of a node \", _jsx(MATHSPAN, {\n          className: \"math math-inline\",\n          latex: \"n\",\n          children: \"<span class=\\\"katex\\\"><span class=\\\"katex-mathml\\\"><math xmlns=\\\"http://www.w3.org/1998/Math/MathML\\\"><semantics><mrow><mi>n</mi></mrow><annotation encoding=\\\"application/x-tex\\\">n</annotation></semantics></math></span><span class=\\\"katex-html\\\" aria-hidden=\\\"true\\\"><span class=\\\"base\\\"><span class=\\\"strut\\\" style=\\\"height:0.4306em;\\\"></span><span class=\\\"mord mathnormal\\\">n</span></span></span></span>\"\n        }), \" is the first node along the path from \", _jsx(MATHSPAN, {\n          className: \"math math-inline\",\n          latex: \"n\",\n          children: \"<span class=\\\"katex\\\"><span class=\\\"katex-mathml\\\"><math xmlns=\\\"http://www.w3.org/1998/Math/MathML\\\"><semantics><mrow><mi>n</mi></mrow><annotation encoding=\\\"application/x-tex\\\">n</annotation></semantics></math></span><span class=\\\"katex-html\\\" aria-hidden=\\\"true\\\"><span class=\\\"base\\\"><span class=\\\"strut\\\" style=\\\"height:0.4306em;\\\"></span><span class=\\\"mord mathnormal\\\">n</span></span></span></span>\"\n        }), \" to the\\n\", _jsx(_components.strong, {\n          children: \"root\"\n        }), \"\\n\", _jsxs(_components.ul, {\n          children: [\"\\n\", _jsxs(_components.li, {\n            children: [\"The \", _jsx(_components.strong, {\n              children: \"root\"\n            }), \" does not have a \", _jsx(_components.strong, {\n              children: \"parent\"\n            }), \". This is typically done in code by\\nsetting the \", _jsx(_components.strong, {\n              children: \"parent\"\n            }), \" of the \", _jsx(_components.strong, {\n              children: \"root\"\n            }), \" to be \", _jsx(MATHSPAN, {\n              className: \"math math-inline\",\n              latex: \"-1\",\n              children: \"<span class=\\\"katex\\\"><span class=\\\"katex-mathml\\\"><math xmlns=\\\"http://www.w3.org/1998/Math/MathML\\\"><semantics><mrow><mo>−</mo><mn>1</mn></mrow><annotation encoding=\\\"application/x-tex\\\">-1</annotation></semantics></math></span><span class=\\\"katex-html\\\" aria-hidden=\\\"true\\\"><span class=\\\"base\\\"><span class=\\\"strut\\\" style=\\\"height:0.7278em;vertical-align:-0.0833em;\\\"></span><span class=\\\"mord\\\">−</span><span class=\\\"mord\\\">1</span></span></span></span>\"\n            }), \".\"]\n          }), \"\\n\"]\n        }), \"\\n\"]\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [\"The \", _jsx(_components.strong, {\n          children: \"ancestors\"\n        }), \" of a node are its \", _jsx(_components.strong, {\n          children: \"parent\"\n        }), \" and \", _jsx(_components.strong, {\n          children: \"parent's\"\n        }), \" \", _jsx(_components.strong, {\n          children: \"ancestors\"\n        }), \"\\n\", _jsxs(_components.ul, {\n          children: [\"\\n\", _jsx(_components.li, {\n            children: \"Typically, a node is considered its own ancestor as well (such as in the\\nsubtree definition)\"\n          }), \"\\n\"]\n        }), \"\\n\"]\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [\"The \", _jsx(_components.strong, {\n          children: \"subtree\"\n        }), \" of a node \", _jsx(MATHSPAN, {\n          className: \"math math-inline\",\n          latex: \"n\",\n          children: \"<span class=\\\"katex\\\"><span class=\\\"katex-mathml\\\"><math xmlns=\\\"http://www.w3.org/1998/Math/MathML\\\"><semantics><mrow><mi>n</mi></mrow><annotation encoding=\\\"application/x-tex\\\">n</annotation></semantics></math></span><span class=\\\"katex-html\\\" aria-hidden=\\\"true\\\"><span class=\\\"base\\\"><span class=\\\"strut\\\" style=\\\"height:0.4306em;\\\"></span><span class=\\\"mord mathnormal\\\">n</span></span></span></span>\"\n        }), \" are the set of nodes that have \", _jsx(MATHSPAN, {\n          className: \"math math-inline\",\n          latex: \"n\",\n          children: \"<span class=\\\"katex\\\"><span class=\\\"katex-mathml\\\"><math xmlns=\\\"http://www.w3.org/1998/Math/MathML\\\"><semantics><mrow><mi>n</mi></mrow><annotation encoding=\\\"application/x-tex\\\">n</annotation></semantics></math></span><span class=\\\"katex-html\\\" aria-hidden=\\\"true\\\"><span class=\\\"base\\\"><span class=\\\"strut\\\" style=\\\"height:0.4306em;\\\"></span><span class=\\\"mord mathnormal\\\">n</span></span></span></span>\"\n        }), \" as an\\nancestor\\n\", _jsxs(_components.ul, {\n          children: [\"\\n\", _jsx(_components.li, {\n            children: \"A node is typically considered to be in its own subtree\"\n          }), \"\\n\", _jsxs(_components.li, {\n            children: [\"Note: This is easily confused with \", _jsx(_components.strong, {\n              children: \"subgraph\"\n            })]\n          }), \"\\n\"]\n        }), \"\\n\"]\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [\"The \", _jsx(_components.strong, {\n          children: \"depth\"\n        }), \", or \", _jsx(_components.strong, {\n          children: \"level\"\n        }), \", of a node is its distance from the root\"]\n      }), \"\\n\"]\n    }), \"\\n\", \"\\n\", _jsxs(_components.h2, {\n      id: \"solution---subordinates\",\n      children: [_jsx(_components.a, {\n        href: \"#solution---subordinates\",\n        \"aria-hidden\": \"true\",\n        tabIndex: \"-1\",\n        className: \"anchor before\",\n        children: _jsx(HeaderLink, {})\n      }), \"Solution - Subordinates\"]\n    }), \"\\n\", \"\\n\", _jsx(_components.p, {\n      children: \"In this problem we are given the parent of each node of a rooted tree, and we\\nwant to compute the subtree size for each node. A subtree is composed of a root\\nnode and the subtrees of the root's children. Thus, the size of a subtree is one\\nplus the size of the root's childrens' subtrees.\"\n    }), \"\\n\", _jsxs(LanguageSection, {\n      children: [_jsx(CPPSection, {\n        children: _jsx(_components.pre, {\n          children: _jsx(_components.code, {\n            className: \"language-cpp\",\n            children: \"#include <bits/stdc++.h>\\nusing namespace std;\\n\\nconst int SZ = 2e5;\\n\\nvector<int> children[SZ];\\nint subtree_size[SZ], depth[SZ];\\n\\nvoid dfs_size(int node) {\\n\\tsubtree_size[node] = 1; // This one represents the root of `node's` subtree\\n\\t// (which would be `node` itself)\\n\\tfor (int child : children[node]) {\\n\\t\\tdepth[child] = depth[node]+1; // not needed for this problem\\n\\t\\tdfs_size(child);\\n\\t\\tsubtree_size[node] += subtree_size[child];\\n\\t\\t// Add `node's` children's subtrees to the size of `node's` subtree\\n\\t}\\n}\\n\\nint main() {\\n\\tint N; cin >> N;\\n\\tfor(int i = 1; i < N; i++) {\\n\\t\\tint parent; cin >> parent; parent--;\\n\\t\\t// this node is the parent of node i ... Also notice\\n\\t\\t// the decrement operator in order to make the node 0-indexed\\n\\t\\tchildren[parent].push_back(i);\\n\\t}\\n\\tdfs_size(0);\\n\\tfor(int i = 0; i < N; i++) {\\n\\t\\tcout << subtree_size[i]-1;\\n\\t\\tif(i != N-1) cout << \\\" \\\";\\n\\t}\\n\\tcout << \\\"\\\\n\\\";\\n}\\n\\n\"\n          })\n        })\n      }), _jsxs(JavaSection, {\n        children: [_jsx(Warning, {\n          children: _jsxs(_components.p, {\n            children: [\"Because Java is so slow, an adjacency list using lists/arraylists results in\\nTLE. Instead, the Java sample code will use the\\n\", _jsx(_components.a, {\n              href: \"https://codeforces.com/blog/entry/67883\",\n              target: \"_blank\",\n              rel: \"nofollow noopener noreferrer\",\n              children: \"Chinese edge representation\"\n            }), \".\"]\n          })\n        }), _jsx(_components.pre, {\n          children: _jsx(_components.code, {\n            className: \"language-java\",\n            children: \"import java.io.*;\\nimport java.util.*;\\n\\npublic class Subordinates\\n{\\n\\tstatic InputReader in = new InputReader(System.in);\\n\\tstatic PrintWriter out = new PrintWriter(System.out);\\n\\n\\tpublic static final int MN = 200020;\\n\\n\\tstatic int N, M, ans;\\n\\tstatic int[] hd = new int[MN], nx = new int[MN], to = new int[MN], s = new int[MN], p = new int[MN];\\n\\n\\tpublic static void adde(int u, int v, int id)\\n\\t{\\n\\t\\tnx[id] = hd[u];\\n\\t\\thd[u] = id;\\n\\t\\tto[id] = v;\\n\\t}\\n\\tpublic static void dfs(int node)\\n\\t{\\n\\t\\ts[node]=1;\\n\\t\\tfor(int id=hd[node];id!=0;id=nx[id])\\n\\t\\t{\\n\\t\\t\\tdfs(to[id]);\\n\\t\\t\\ts[node]+=s[to[id]];\\n\\t\\t}\\n\\t}\\n\\tpublic static void main(String... args)\\n\\t{\\n\\t\\tN=in.nextInt();\\n\\t\\tfor(int i=2;i<=N;++i)\\n\\t\\t{\\n\\t\\t\\tp[i]=in.nextInt();\\n\\t\\t\\tadde(p[i], i, i);\\n\\t\\t}\\n\\t\\tdfs(1);\\n\\t\\tfor(int i=1;i<=N;++i)\\n\\t\\t{\\n\\t\\t\\tout.print(s[i]-1);\\n\\t\\t\\tif(i<N) out.print(\\\" \\\");\\n\\t\\t\\telse out.println();\\n\\t\\t}\\n\\t\\tout.close();\\n\\t}\\n}\\n\"\n          })\n        })]\n      }), _jsxs(PySection, {\n        children: [_jsxs(_components.p, {\n          children: [\"In the Python solution, we need to set recursion limit to \", _jsx(MATHSPAN, {\n            className: \"math math-inline\",\n            latex: \"2\\\\times10^5\",\n            children: \"<span class=\\\"katex\\\"><span class=\\\"katex-mathml\\\"><math xmlns=\\\"http://www.w3.org/1998/Math/MathML\\\"><semantics><mrow><mn>2</mn><mo>×</mo><mn>1</mn><msup><mn>0</mn><mn>5</mn></msup></mrow><annotation encoding=\\\"application/x-tex\\\">2\\\\times10^5</annotation></semantics></math></span><span class=\\\"katex-html\\\" aria-hidden=\\\"true\\\"><span class=\\\"base\\\"><span class=\\\"strut\\\" style=\\\"height:0.7278em;vertical-align:-0.0833em;\\\"></span><span class=\\\"mord\\\">2</span><span class=\\\"mspace\\\" style=\\\"margin-right:0.2222em;\\\"></span><span class=\\\"mbin\\\">×</span><span class=\\\"mspace\\\" style=\\\"margin-right:0.2222em;\\\"></span></span><span class=\\\"base\\\"><span class=\\\"strut\\\" style=\\\"height:0.8141em;\\\"></span><span class=\\\"mord\\\">1</span><span class=\\\"mord\\\"><span class=\\\"mord\\\">0</span><span class=\\\"msupsub\\\"><span class=\\\"vlist-t\\\"><span class=\\\"vlist-r\\\"><span class=\\\"vlist\\\" style=\\\"height:0.8141em;\\\"><span style=\\\"top:-3.063em;margin-right:0.05em;\\\"><span class=\\\"pstrut\\\" style=\\\"height:2.7em;\\\"></span><span class=\\\"sizing reset-size6 size3 mtight\\\"><span class=\\\"mord mtight\\\">5</span></span></span></span></span></span></span></span></span></span></span>\"\n          }), \".\"]\n        }), _jsx(_components.pre, {\n          children: _jsx(_components.code, {\n            className: \"language-python\",\n            children: \"import sys\\nsys.setrecursionlimit(200006) # set recursion limit\\ndef dfs(x): # x is the current node\\n\\tans = 0 # stores the number of subordinates\\n\\tfor e in edges[x]:\\n\\t\\tif e != fa[x-1]:\\n\\t\\t\\tans += dfs(e)\\n\\tsub[x-1] = ans # 0-index is more convenient for printing\\n\\treturn ans+1 # add the node x itself\\nN = int(input())\\nedges = [[] for _ in range(N+1)] # create empty adjacency list\\nsub = [0 for _ in range(N)] # the number of subordinates\\nfa = [1] + list(map(int, input().split())) # the parent of each node, set the parent of node 1 to itself\\nfor ind, f in enumerate(fa):\\n\\tedges[f].append(ind+1) # add edges to the adjacency list\\ndfs(1)\\nfor i in sub:\\n\\tprint(i, end=\\\" \\\")\\n\"\n          })\n        })]\n      })]\n    }), \"\\n\", \"\\n\", _jsxs(_components.h2, {\n      id: \"quiz\",\n      children: [_jsx(_components.a, {\n        href: \"#quiz\",\n        \"aria-hidden\": \"true\",\n        tabIndex: \"-1\",\n        className: \"anchor before\",\n        children: _jsx(HeaderLink, {})\n      }), \"Quiz\"]\n    }), \"\\n\", _jsxs(Quiz, {\n      children: [_jsxs(Quiz.Question, {\n        children: [_jsx(_components.p, {\n          children: \"How is a preorder traversal found for a binary tree?\"\n        }), _jsxs(Quiz.Answer, {\n          correct: true,\n          children: [_jsx(_components.p, {\n            children: \"Add the current node to the list, and then run DFS on all child nodes of the current node from left to right.\"\n          }), _jsx(Quiz.Explanation, {\n            children: _jsx(_components.p, {\n              children: \"Correct! Adding the current node first is preorder traversal. Adding it between the two child nodes is inorder, and adding it after the two child nodes is postorder.\"\n            })\n          })]\n        }), _jsxs(Quiz.Answer, {\n          children: [_jsx(_components.p, {\n            children: \"Run DFS on the left node, add the current node to the list, and then run DFS on the right node.\"\n          }), _jsx(Quiz.Explanation, {\n            children: _jsx(_components.p, {\n              children: \"Incorrect. This is inorder traversal.\"\n            })\n          })]\n        }), _jsxs(Quiz.Answer, {\n          children: [_jsx(_components.p, {\n            children: \"Run DFS on the right node, add the current node to the list, and then run DFS on the left node.\"\n          }), _jsx(Quiz.Explanation, {\n            children: _jsx(_components.p, {\n              children: \"Incorrect. This is neither preorder, inorder, or postorder traversal.\"\n            })\n          })]\n        }), _jsxs(Quiz.Answer, {\n          children: [_jsx(_components.p, {\n            children: \"Run DFS on all child nodes of the current node from left to right, then add the current node to the list.\"\n          }), _jsx(Quiz.Explanation, {\n            children: _jsx(_components.p, {\n              children: \"Incorrect. This is postorder traversal.\"\n            })\n          })]\n        })]\n      }), _jsxs(Quiz.Question, {\n        children: [_jsx(_components.p, {\n          children: \"What is the diameter of a tree?\"\n        }), _jsxs(Quiz.Answer, {\n          children: [_jsx(_components.p, {\n            children: \"The length of the longest path from root to leaf node\"\n          }), _jsx(Quiz.Explanation, {\n            children: _jsx(_components.p, {\n              children: \"False. The diameter of a tree is the maximum distance between two nodes, which usually isn't the longest distance between the root and the leaf. The only exception is if the root is a leaf along the longest path of a tree.\"\n            })\n          })]\n        }), _jsxs(Quiz.Answer, {\n          children: [_jsx(_components.p, {\n            children: \"The length of the longest path that exists in the tree\"\n          }), _jsx(Quiz.Explanation, {\n            children: _jsx(_components.p, {\n              children: \"This statement is true, but 3 is also true.\"\n            })\n          })]\n        }), _jsxs(Quiz.Answer, {\n          children: [_jsx(_components.p, {\n            children: \"The length of the longest path from two leaf nodes\"\n          }), _jsx(Quiz.Explanation, {\n            children: _jsx(_components.p, {\n              children: \"This statement is true, but 2 is also true.\"\n            })\n          })]\n        }), _jsxs(Quiz.Answer, {\n          correct: true,\n          children: [_jsx(_components.p, {\n            children: \"Both 2 and 3\"\n          }), _jsx(Quiz.Explanation, {\n            children: _jsx(_components.p, {\n              children: \"Correct! The diameter is the longest path between two nodes in a tree, but the longest path must be a path between two leaf nodes. If we have a path between two nodes that are not leaves, it can't be the longest because we can extend our path further down the tree in either direction.\"\n            })\n          })]\n        })]\n      }), _jsxs(Quiz.Question, {\n        children: [_jsxs(_components.p, {\n          children: [\"What would be a valid function header for DFS on an undirected tree to work in linear time \", _jsx(_components.em, {\n            children: \"without\"\n          }), \" any other variables?\"]\n        }), _jsxs(Quiz.Answer, {\n          correct: true,\n          children: [_jsx(_components.p, {\n            children: _jsx(_components.code, {\n              children: \"void dfs(int v, int p, vector<vector<int>>& adj)\"\n            })\n          }), _jsxs(Quiz.Explanation, {\n            children: [_jsxs(_components.p, {\n              children: [\"Correct! For a tree, we do not need a visited array. We only need to check if we are revisiting the parent node, so \", _jsx(_components.code, {\n                children: \"v\"\n              }), \" as a current node and \", _jsx(_components.code, {\n                children: \"p\"\n              }), \" as a parent node would work.\"]\n            }), _jsxs(_components.p, {\n              children: [\"Calling \", _jsx(_components.code, {\n                children: \"adj\"\n              }), \" as a \", _jsx(_components.code, {\n                children: \"vector<vector<int>>&\"\n              }), \" instead of just \", _jsx(_components.code, {\n                children: \"vector<vector<int>>\"\n              }), \" ensures that the reference (instead of the entire list) is copied over each time, which takes constant instead of linear time. Therefore, the entire DFS would take linear time.\"]\n            })]\n          })]\n        }), _jsxs(Quiz.Answer, {\n          children: [_jsx(_components.p, {\n            children: _jsx(_components.code, {\n              children: \"void dfs(int v, int p, vector<vector<int>> adj)\"\n            })\n          }), _jsx(Quiz.Explanation, {\n            children: _jsxs(_components.p, {\n              children: [\"Incorrect. This would not work in linear time because \", _jsx(_components.code, {\n                children: \"adj\"\n              }), \" would be copied in \", _jsx(MATHSPAN, {\n                className: \"math math-inline\",\n                latex: \"O(n)\",\n                children: \"<span class=\\\"katex\\\"><span class=\\\"katex-mathml\\\"><math xmlns=\\\"http://www.w3.org/1998/Math/MathML\\\"><semantics><mrow><mi>O</mi><mo stretchy=\\\"false\\\">(</mo><mi>n</mi><mo stretchy=\\\"false\\\">)</mo></mrow><annotation encoding=\\\"application/x-tex\\\">O(n)</annotation></semantics></math></span><span class=\\\"katex-html\\\" aria-hidden=\\\"true\\\"><span class=\\\"base\\\"><span class=\\\"strut\\\" style=\\\"height:1em;vertical-align:-0.25em;\\\"></span><span class=\\\"mord mathnormal\\\" style=\\\"margin-right:0.02778em;\\\">O</span><span class=\\\"mopen\\\">(</span><span class=\\\"mord mathnormal\\\">n</span><span class=\\\"mclose\\\">)</span></span></span></span>\"\n              }), \" time every time DFS is called. As DFS is called \", _jsx(MATHSPAN, {\n                className: \"math math-inline\",\n                latex: \"n\",\n                children: \"<span class=\\\"katex\\\"><span class=\\\"katex-mathml\\\"><math xmlns=\\\"http://www.w3.org/1998/Math/MathML\\\"><semantics><mrow><mi>n</mi></mrow><annotation encoding=\\\"application/x-tex\\\">n</annotation></semantics></math></span><span class=\\\"katex-html\\\" aria-hidden=\\\"true\\\"><span class=\\\"base\\\"><span class=\\\"strut\\\" style=\\\"height:0.4306em;\\\"></span><span class=\\\"mord mathnormal\\\">n</span></span></span></span>\"\n              }), \" times, this runs in \", _jsx(MATHSPAN, {\n                className: \"math math-inline\",\n                latex: \"O(n^2)\",\n                children: \"<span class=\\\"katex\\\"><span class=\\\"katex-mathml\\\"><math xmlns=\\\"http://www.w3.org/1998/Math/MathML\\\"><semantics><mrow><mi>O</mi><mo stretchy=\\\"false\\\">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo stretchy=\\\"false\\\">)</mo></mrow><annotation encoding=\\\"application/x-tex\\\">O(n^2)</annotation></semantics></math></span><span class=\\\"katex-html\\\" aria-hidden=\\\"true\\\"><span class=\\\"base\\\"><span class=\\\"strut\\\" style=\\\"height:1.0641em;vertical-align:-0.25em;\\\"></span><span class=\\\"mord mathnormal\\\" style=\\\"margin-right:0.02778em;\\\">O</span><span class=\\\"mopen\\\">(</span><span class=\\\"mord\\\"><span class=\\\"mord mathnormal\\\">n</span><span class=\\\"msupsub\\\"><span class=\\\"vlist-t\\\"><span class=\\\"vlist-r\\\"><span class=\\\"vlist\\\" style=\\\"height:0.8141em;\\\"><span style=\\\"top:-3.063em;margin-right:0.05em;\\\"><span class=\\\"pstrut\\\" style=\\\"height:2.7em;\\\"></span><span class=\\\"sizing reset-size6 size3 mtight\\\"><span class=\\\"mord mtight\\\">2</span></span></span></span></span></span></span></span><span class=\\\"mclose\\\">)</span></span></span></span>\"\n              }), \".\"]\n            })\n          })]\n        }), _jsxs(Quiz.Answer, {\n          children: [_jsx(_components.p, {\n            children: _jsx(_components.code, {\n              children: \"void dfs(int v, vector<vector<int>> adj)\"\n            })\n          }), _jsx(Quiz.Explanation, {\n            children: _jsx(_components.p, {\n              children: \"Incorrect. This DFS function cannot check for a parent node, and therefore would never terminate.\"\n            })\n          })]\n        }), _jsxs(Quiz.Answer, {\n          children: [_jsx(_components.p, {\n            children: _jsx(_components.code, {\n              children: \"void dfs(vector<vector<int>>& adj)\"\n            })\n          }), _jsx(Quiz.Explanation, {\n            children: _jsx(_components.p, {\n              children: \"Incorrect. This DFS function cannot track the current node, therefore it cannot even run.\"\n            })\n          })]\n        })]\n      })]\n    }), \"\\n\", _jsxs(_components.h2, {\n      id: \"problems\",\n      children: [_jsx(_components.a, {\n        href: \"#problems\",\n        \"aria-hidden\": \"true\",\n        tabIndex: \"-1\",\n        className: \"anchor before\",\n        children: _jsx(HeaderLink, {})\n      }), \"Problems\"]\n    }), \"\\n\", \"\\n\", _jsx(Problems, {\n      problems: \"tree\",\n      hideSuggestProblemButton: true\n    })]\n  });\n  return MDXLayout ? _jsx(MDXLayout, Object.assign({}, _props, {\n    children: _content\n  })) : _content;\n}\nreturn {\n  id,\n  title,\n  author,\n  prerequisites,\n  description,\n  frequency,\n  default: MDXContent\n};\n","frontmatter":{"title":"Introduction to Tree Algorithms","author":"Nathan Chen, Siyong Huang, Albert Ye","contributors":null,"id":"intro-tree","prerequisites":["dfs"],"description":"Introducing a special type of graph: trees.","frequency":1},"parent":{"name":"Intro_Tree","relativePath":"3_Silver/Intro_Tree.mdx"},"fields":{"division":"silver"},"toc":{"cpp":[{"depth":2,"value":"Resources","slug":"resources"},{"depth":2,"value":"Solution - Subordinates","slug":"solution---subordinates"},{"depth":2,"value":"Quiz","slug":"quiz"},{"depth":2,"value":"Problems","slug":"problems"}],"java":[{"depth":2,"value":"Resources","slug":"resources"},{"depth":2,"value":"Solution - Subordinates","slug":"solution---subordinates"},{"depth":2,"value":"Quiz","slug":"quiz"},{"depth":2,"value":"Problems","slug":"problems"}],"py":[{"depth":2,"value":"Resources","slug":"resources"},{"depth":2,"value":"Solution - Subordinates","slug":"solution---subordinates"},{"depth":2,"value":"Quiz","slug":"quiz"},{"depth":2,"value":"Problems","slug":"problems"}]}},"moduleProblemLists":{"problemLists":[{"listId":"treeSam","problems":[{"uniqueId":"cses-1674","name":"Subordinates","url":"https://cses.fi/problemset/task/1674","source":"CSES","difficulty":"Easy","isStarred":false,"tags":["Tree"],"solution":{"kind":"link","label":"In Module","labelTooltip":null,"url":"https://usaco.guide/silver/intro-tree#problem-cses-1674","sketch":null}}]},{"listId":"tree","problems":[{"uniqueId":"cf-755C","name":"PolandBall & Forest","url":"https://codeforces.com/contest/755/problem/C","source":"CF","difficulty":"Easy","isStarred":false,"tags":["Tree","Connected Components","Diameter"],"solution":{"kind":"label","label":"Check CF","labelTooltip":"Check contest materials, located to the right of the problem statement.","url":null,"sketch":null}},{"uniqueId":"usaco-788","name":"Mootube","url":"http://www.usaco.org/index.php?page=viewproblem2&cpid=788","source":"Silver","difficulty":"Easy","isStarred":true,"tags":["Tree","Connected Components"],"solution":{"kind":"internal","label":null,"labelTooltip":null,"url":null,"sketch":null}},{"uniqueId":"cf-839C","name":"Journey","url":"https://codeforces.com/contest/839/problem/C","source":"CF","difficulty":"Easy","isStarred":false,"tags":["Tree"],"solution":{"kind":"label","label":"Check CF","labelTooltip":"Check contest materials, located to the right of the problem statement.","url":null,"sketch":null}},{"uniqueId":"usaco-968","name":"Milk Visits","url":"http://www.usaco.org/index.php?page=viewproblem2&cpid=968","source":"Silver","difficulty":"Easy","isStarred":true,"tags":["Tree","Connected Components"],"solution":{"kind":"internal","label":null,"labelTooltip":null,"url":null,"sketch":null}},{"uniqueId":"usaco-1062","name":"Cowntagion","url":"http://www.usaco.org/index.php?page=viewproblem2&cpid=1062","source":"Silver","difficulty":"Easy","isStarred":false,"tags":["Greedy","Tree"],"solution":{"kind":"internal","label":null,"labelTooltip":null,"url":null,"sketch":null}},{"uniqueId":"usaco-833","name":"Family Tree","url":"http://www.usaco.org/index.php?page=viewproblem2&cpid=833","source":"Bronze","difficulty":"Easy","isStarred":false,"tags":["Tree"],"solution":{"kind":"internal","label":null,"labelTooltip":null,"url":null,"sketch":null}},{"uniqueId":"cses-1131","name":"Tree Diameter","url":"https://cses.fi/problemset/task/1131","source":"CSES","difficulty":"Normal","isStarred":true,"tags":["Tree"],"solution":{"kind":"link","label":"CPH 14.2","labelTooltip":null,"url":"/CPH.pdf#page=145","sketch":null}},{"uniqueId":"cses-1132","name":"Tree Distances I","url":"https://cses.fi/problemset/task/1132","source":"CSES","difficulty":"Normal","isStarred":false,"tags":["Tree"],"solution":{"kind":"internal","label":null,"labelTooltip":null,"url":null,"sketch":null}},{"uniqueId":"cses-1133","name":"Tree Distances II","url":"https://cses.fi/problemset/task/1133","source":"CSES","difficulty":"Normal","isStarred":false,"tags":["Tree"],"solution":{"kind":"internal","label":null,"labelTooltip":null,"url":null,"sketch":null}},{"uniqueId":"usaco-1016","name":"Clock Tree","url":"http://www.usaco.org/index.php?page=viewproblem2&cpid=1016","source":"Silver","difficulty":"Normal","isStarred":false,"tags":["Tree","Bipartite"],"solution":{"kind":"internal","label":null,"labelTooltip":null,"url":null,"sketch":null}},{"uniqueId":"cses-2179","name":"Even Outdegree Edges","url":"https://cses.fi/problemset/task/2179","source":"CSES","difficulty":"Hard","isStarred":true,"tags":["DFS","Spanning Tree"],"solution":{"kind":"internal","label":null,"labelTooltip":null,"url":null,"sketch":null}},{"uniqueId":"cf-860D","name":"Wizard's Tour","url":"https://codeforces.com/contest/860/problem/D","source":"CF","difficulty":"Hard","isStarred":false,"tags":["DFS","Spanning Tree"],"solution":{"kind":"internal","label":null,"labelTooltip":null,"url":null,"sketch":null}}]}]}},"pageContext":{"id":"intro-tree"}},
    "staticQueryHashes": ["3245546052","3813215756","745520438"]}